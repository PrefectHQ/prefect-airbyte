{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"prefect-airbyte Welcome! prefect-airbyte is a collection of prebuilt Prefect tasks that can be used to quickly construct Prefect flows to trigger Airbyte syncs or export your connector configurations. Getting Started Python setup Requires an installation of Python 3.7+ We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation . Airbyte setup See the airbyte documention on how to get your own instance. Installation Install prefect-airbyte pip install prefect-airbyte Examples Create an AirbyteServer block and save it from prefect_airbyte.server import AirbyteServer # running airbyte locally at http://localhost:8000 with default auth local_airbyte_server = AirbyteServer () # running airbyte remotely at http://<someIP>:<somePort> as user `Marvin` remote_airbyte_server = AirbyteServer ( username = \"Marvin\" , password = \"DontPanic42\" , server_host = \"42.42.42.42\" , server_port = \"4242\" ) local_airbyte_server . save ( \"my-local-airbyte-server\" ) remote_airbyte_server . save ( \"my-remote-airbyte-server\" ) Trigger a defined connection sync from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( airbyte_server = AirbyteServer . load ( \"my-airbyte-server\" ), connection_id = \"your-connection-id-to-sync\" , poll_interval_s = 3 , status_updates = True ) example_trigger_sync_flow () \u276f python airbyte_syncs.py 03:46:03 | prefect.engine - Created flow run 'thick-seahorse' for flow 'example_trigger_sync_flow' 03:46:03 | Flow run 'thick-seahorse' - Using task runner 'ConcurrentTaskRunner' 03:46:03 | Flow run 'thick-seahorse' - Created task run 'trigger_sync-35f0e9c2-0' for task 'trigger_sync' 03:46:03 | prefect - trigger airbyte connection: e1b2078f-882a-4f50-9942-cfe34b2d825b, poll interval 3 seconds 03:46:03 | prefect - pending 03:46:06 | prefect - running 03:46:09 | prefect - running 03:46:12 | prefect - running 03:46:16 | prefect - running 03:46:19 | prefect - running 03:46:22 | prefect - Job 26 succeeded. 03:46:22 | Task run 'trigger_sync-35f0e9c2-0' - Finished in state Completed(None) 03:46:22 | Flow run 'thick-seahorse' - Finished in state Completed('All states completed.') Export an Airbyte instance's configuration NOTE : The API endpoint corresponding to this task is no longer supported by open-source Airbyte versions as of v0.40.7. Check out the Octavia CLI docs for more info. import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere ( airbyte_config : bytearray , somewhere : str , ): with gzip . open ( somewhere , 'wb' ) as f : f . write ( airbyte_config ) @flow def example_export_configuration_flow ( filepath : str ): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server = AirbyteServer . load ( \"my-airbyte-server-block\" ) ) zip_and_write_somewhere ( somewhere = filepath , airbyte_config = airbyte_config ) if __name__ == \"__main__\" : example_export_configuration_flow ( '*://**/my_destination.gz' ) Resources If you encounter and bugs while using prefect-airbyte , feel free to open an issue in the prefect-airbyte repository. If you have any questions or issues while using prefect-airbyte , you can find help in either the Prefect Discourse forum or the Prefect Slack community Feel free to \u2b50\ufe0f or watch prefect-airbyte for updates too! Development If you'd like to install a version of prefect-airbyte for development, first clone the repository and then perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-airbyte.git cd prefect-airbyte/ pip install -e \".[dev]\"","title":"Home"},{"location":"#prefect-airbyte","text":"","title":"prefect-airbyte"},{"location":"#welcome","text":"prefect-airbyte is a collection of prebuilt Prefect tasks that can be used to quickly construct Prefect flows to trigger Airbyte syncs or export your connector configurations.","title":"Welcome!"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#python-setup","text":"Requires an installation of Python 3.7+ We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation .","title":"Python setup"},{"location":"#airbyte-setup","text":"See the airbyte documention on how to get your own instance.","title":"Airbyte setup"},{"location":"#installation","text":"Install prefect-airbyte pip install prefect-airbyte","title":"Installation"},{"location":"#examples","text":"","title":"Examples"},{"location":"#create-an-airbyteserver-block-and-save-it","text":"from prefect_airbyte.server import AirbyteServer # running airbyte locally at http://localhost:8000 with default auth local_airbyte_server = AirbyteServer () # running airbyte remotely at http://<someIP>:<somePort> as user `Marvin` remote_airbyte_server = AirbyteServer ( username = \"Marvin\" , password = \"DontPanic42\" , server_host = \"42.42.42.42\" , server_port = \"4242\" ) local_airbyte_server . save ( \"my-local-airbyte-server\" ) remote_airbyte_server . save ( \"my-remote-airbyte-server\" )","title":"Create an AirbyteServer block and save it"},{"location":"#trigger-a-defined-connection-sync","text":"from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( airbyte_server = AirbyteServer . load ( \"my-airbyte-server\" ), connection_id = \"your-connection-id-to-sync\" , poll_interval_s = 3 , status_updates = True ) example_trigger_sync_flow () \u276f python airbyte_syncs.py 03:46:03 | prefect.engine - Created flow run 'thick-seahorse' for flow 'example_trigger_sync_flow' 03:46:03 | Flow run 'thick-seahorse' - Using task runner 'ConcurrentTaskRunner' 03:46:03 | Flow run 'thick-seahorse' - Created task run 'trigger_sync-35f0e9c2-0' for task 'trigger_sync' 03:46:03 | prefect - trigger airbyte connection: e1b2078f-882a-4f50-9942-cfe34b2d825b, poll interval 3 seconds 03:46:03 | prefect - pending 03:46:06 | prefect - running 03:46:09 | prefect - running 03:46:12 | prefect - running 03:46:16 | prefect - running 03:46:19 | prefect - running 03:46:22 | prefect - Job 26 succeeded. 03:46:22 | Task run 'trigger_sync-35f0e9c2-0' - Finished in state Completed(None) 03:46:22 | Flow run 'thick-seahorse' - Finished in state Completed('All states completed.')","title":"Trigger a defined connection sync"},{"location":"#export-an-airbyte-instances-configuration","text":"NOTE : The API endpoint corresponding to this task is no longer supported by open-source Airbyte versions as of v0.40.7. Check out the Octavia CLI docs for more info. import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere ( airbyte_config : bytearray , somewhere : str , ): with gzip . open ( somewhere , 'wb' ) as f : f . write ( airbyte_config ) @flow def example_export_configuration_flow ( filepath : str ): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server = AirbyteServer . load ( \"my-airbyte-server-block\" ) ) zip_and_write_somewhere ( somewhere = filepath , airbyte_config = airbyte_config ) if __name__ == \"__main__\" : example_export_configuration_flow ( '*://**/my_destination.gz' )","title":"Export an Airbyte instance's configuration"},{"location":"#resources","text":"If you encounter and bugs while using prefect-airbyte , feel free to open an issue in the prefect-airbyte repository. If you have any questions or issues while using prefect-airbyte , you can find help in either the Prefect Discourse forum or the Prefect Slack community Feel free to \u2b50\ufe0f or watch prefect-airbyte for updates too!","title":"Resources"},{"location":"#development","text":"If you'd like to install a version of prefect-airbyte for development, first clone the repository and then perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-airbyte.git cd prefect-airbyte/ pip install -e \".[dev]\"","title":"Development"},{"location":"client/","text":"prefect_airbyte.client Client for interacting with Airbyte instance Classes AirbyteClient Client class used to call API endpoints on an Airbyte server. This client currently supports username/password authentication as set in auth . For more info, see the Airbyte docs . Attributes: Name Type Description airbyte_base_url str Base API endpoint URL for Airbyte. auth Username and password for Airbyte API. logger A logger instance used by the client to log messages related to API calls. timeout The number of seconds to wait before an API call times out. Source code in prefect_airbyte/client.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class AirbyteClient : \"\"\" Client class used to call API endpoints on an Airbyte server. This client currently supports username/password authentication as set in `auth`. For more info, see the [Airbyte docs](https://docs.airbyte.io/api-documentation). Attributes: airbyte_base_url str: Base API endpoint URL for Airbyte. auth: Username and password for Airbyte API. logger: A logger instance used by the client to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. \"\"\" def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , auth : Tuple [ str , str ] = ( \"airbyte\" , \"password\" ), timeout : int = 5 , ): self . _closed = False self . _started = False self . airbyte_base_url = airbyte_base_url self . auth = auth self . logger = logger self . timeout = timeout self . _client = httpx . AsyncClient ( base_url = self . airbyte_base_url , auth = self . auth , timeout = self . timeout ) async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an AirbyteInstance. Args: Session used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. Returns: Gzipped Airbyte configuration data. \"\"\" warn ( \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \" \"exporting configurations. See the Octavia CLI docs for more info.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await self . _client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : if e . response . status_code == 404 : self . logger . error ( \"If you are using Airbyte v0.40.7-alpha, there is no longer \" \"an API endpoint for exporting configurations.\" ) raise err . AirbyteExportConfigurationFailed () from e async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/sync/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def get_job_status ( self , job_id : str ) -> Tuple [ str , str , str ]: \"\"\" Gets the status of an Airbyte connection sync job. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def create_client ( self ) -> httpx . AsyncClient : \"\"\"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire `AirbyteClient` class as a context manager. \"\"\" warn ( \"Use of this method will be removed in a future release - \" \"please use the `AirbyteClient` class as a context manager.\" , DeprecationWarning , stacklevel = 2 , ) return self . _client async def __aenter__ ( self ): \"\"\"Context manager entry point.\"\"\" if self . _closed : raise RuntimeError ( \"The client cannot be started again after it has been closed.\" ) if self . _started : raise RuntimeError ( \"The client cannot be started more than once.\" ) self . _started = True await self . check_health_status ( self . _client ) return self async def __aexit__ ( self , * exc ): \"\"\"Context manager exit point.\"\"\" self . _closed = True await self . _client . __aexit__ () Functions __aenter__ async Context manager entry point. Source code in prefect_airbyte/client.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 async def __aenter__ ( self ): \"\"\"Context manager entry point.\"\"\" if self . _closed : raise RuntimeError ( \"The client cannot be started again after it has been closed.\" ) if self . _started : raise RuntimeError ( \"The client cannot be started more than once.\" ) self . _started = True await self . check_health_status ( self . _client ) return self __aexit__ async Context manager exit point. Source code in prefect_airbyte/client.py 222 223 224 225 226 async def __aexit__ ( self , * exc ): \"\"\"Context manager exit point.\"\"\" self . _closed = True await self . _client . __aexit__ () check_health_status async Checks the health status of an AirbyteInstance. Returns: Type Description bool True if the server is healthy. False otherwise. Source code in prefect_airbyte/client.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an AirbyteInstance. Args: Session used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e create_client async Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire AirbyteClient class as a context manager. Source code in prefect_airbyte/client.py 193 194 195 196 197 198 199 200 201 202 203 204 205 async def create_client ( self ) -> httpx . AsyncClient : \"\"\"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire `AirbyteClient` class as a context manager. \"\"\" warn ( \"Use of this method will be removed in a future release - \" \"please use the `AirbyteClient` class as a context manager.\" , DeprecationWarning , stacklevel = 2 , ) return self . _client export_configuration async Triggers an export of Airbyte configuration. Returns: Type Description bytes Gzipped Airbyte configuration data. Source code in prefect_airbyte/client.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. Returns: Gzipped Airbyte configuration data. \"\"\" warn ( \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \" \"exporting configurations. See the Octavia CLI docs for more info.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await self . _client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : if e . response . status_code == 404 : self . logger . error ( \"If you are using Airbyte v0.40.7-alpha, there is no longer \" \"an API endpoint for exporting configurations.\" ) raise err . AirbyteExportConfigurationFailed () from e get_connection_status async Gets the status of a defined Airbyte connection. Parameters: Name Type Description Default connection_id str ID of an existing Airbyte connection. required Returns: Type Description str The status of the defined Airbyte connection. Source code in prefect_airbyte/client.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e get_job_status async Gets the status of an Airbyte connection sync job. Parameters: Name Type Description Default job_id str ID of the Airbyte job to check. required Returns: Name Type Description job_status str The current status of the job. job_created_at str Datetime string of when the job was created. job_updated_at str Datetime string of the when the job was last updated. Source code in prefect_airbyte/client.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 async def get_job_status ( self , job_id : str ) -> Tuple [ str , str , str ]: \"\"\" Gets the status of an Airbyte connection sync job. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e trigger_manual_sync_connection async Triggers a manual sync of the connection. Parameters: Name Type Description Default connection_id str ID of connection to sync. required Returns: Name Type Description job_id str ID of the job that was triggered. created_at str Datetime string of when the job was created. Source code in prefect_airbyte/client.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/sync/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"Client"},{"location":"client/#prefect_airbyte.client","text":"Client for interacting with Airbyte instance","title":"client"},{"location":"client/#prefect_airbyte.client-classes","text":"","title":"Classes"},{"location":"client/#prefect_airbyte.client.AirbyteClient","text":"Client class used to call API endpoints on an Airbyte server. This client currently supports username/password authentication as set in auth . For more info, see the Airbyte docs . Attributes: Name Type Description airbyte_base_url str Base API endpoint URL for Airbyte. auth Username and password for Airbyte API. logger A logger instance used by the client to log messages related to API calls. timeout The number of seconds to wait before an API call times out. Source code in prefect_airbyte/client.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class AirbyteClient : \"\"\" Client class used to call API endpoints on an Airbyte server. This client currently supports username/password authentication as set in `auth`. For more info, see the [Airbyte docs](https://docs.airbyte.io/api-documentation). Attributes: airbyte_base_url str: Base API endpoint URL for Airbyte. auth: Username and password for Airbyte API. logger: A logger instance used by the client to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. \"\"\" def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , auth : Tuple [ str , str ] = ( \"airbyte\" , \"password\" ), timeout : int = 5 , ): self . _closed = False self . _started = False self . airbyte_base_url = airbyte_base_url self . auth = auth self . logger = logger self . timeout = timeout self . _client = httpx . AsyncClient ( base_url = self . airbyte_base_url , auth = self . auth , timeout = self . timeout ) async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an AirbyteInstance. Args: Session used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. Returns: Gzipped Airbyte configuration data. \"\"\" warn ( \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \" \"exporting configurations. See the Octavia CLI docs for more info.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await self . _client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : if e . response . status_code == 404 : self . logger . error ( \"If you are using Airbyte v0.40.7-alpha, there is no longer \" \"an API endpoint for exporting configurations.\" ) raise err . AirbyteExportConfigurationFailed () from e async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/sync/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def get_job_status ( self , job_id : str ) -> Tuple [ str , str , str ]: \"\"\" Gets the status of an Airbyte connection sync job. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def create_client ( self ) -> httpx . AsyncClient : \"\"\"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire `AirbyteClient` class as a context manager. \"\"\" warn ( \"Use of this method will be removed in a future release - \" \"please use the `AirbyteClient` class as a context manager.\" , DeprecationWarning , stacklevel = 2 , ) return self . _client async def __aenter__ ( self ): \"\"\"Context manager entry point.\"\"\" if self . _closed : raise RuntimeError ( \"The client cannot be started again after it has been closed.\" ) if self . _started : raise RuntimeError ( \"The client cannot be started more than once.\" ) self . _started = True await self . check_health_status ( self . _client ) return self async def __aexit__ ( self , * exc ): \"\"\"Context manager exit point.\"\"\" self . _closed = True await self . _client . __aexit__ ()","title":"AirbyteClient"},{"location":"client/#prefect_airbyte.client.AirbyteClient-functions","text":"","title":"Functions"},{"location":"client/#prefect_airbyte.client.AirbyteClient.__aenter__","text":"Context manager entry point. Source code in prefect_airbyte/client.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 async def __aenter__ ( self ): \"\"\"Context manager entry point.\"\"\" if self . _closed : raise RuntimeError ( \"The client cannot be started again after it has been closed.\" ) if self . _started : raise RuntimeError ( \"The client cannot be started more than once.\" ) self . _started = True await self . check_health_status ( self . _client ) return self","title":"__aenter__()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.__aexit__","text":"Context manager exit point. Source code in prefect_airbyte/client.py 222 223 224 225 226 async def __aexit__ ( self , * exc ): \"\"\"Context manager exit point.\"\"\" self . _closed = True await self . _client . __aexit__ ()","title":"__aexit__()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.check_health_status","text":"Checks the health status of an AirbyteInstance. Returns: Type Description bool True if the server is healthy. False otherwise. Source code in prefect_airbyte/client.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an AirbyteInstance. Args: Session used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e","title":"check_health_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.create_client","text":"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire AirbyteClient class as a context manager. Source code in prefect_airbyte/client.py 193 194 195 196 197 198 199 200 201 202 203 204 205 async def create_client ( self ) -> httpx . AsyncClient : \"\"\"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire `AirbyteClient` class as a context manager. \"\"\" warn ( \"Use of this method will be removed in a future release - \" \"please use the `AirbyteClient` class as a context manager.\" , DeprecationWarning , stacklevel = 2 , ) return self . _client","title":"create_client()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.export_configuration","text":"Triggers an export of Airbyte configuration. Returns: Type Description bytes Gzipped Airbyte configuration data. Source code in prefect_airbyte/client.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. Returns: Gzipped Airbyte configuration data. \"\"\" warn ( \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \" \"exporting configurations. See the Octavia CLI docs for more info.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await self . _client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : if e . response . status_code == 404 : self . logger . error ( \"If you are using Airbyte v0.40.7-alpha, there is no longer \" \"an API endpoint for exporting configurations.\" ) raise err . AirbyteExportConfigurationFailed () from e","title":"export_configuration()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_connection_status","text":"Gets the status of a defined Airbyte connection. Parameters: Name Type Description Default connection_id str ID of an existing Airbyte connection. required Returns: Type Description str The status of the defined Airbyte connection. Source code in prefect_airbyte/client.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e","title":"get_connection_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_job_status","text":"Gets the status of an Airbyte connection sync job. Parameters: Name Type Description Default job_id str ID of the Airbyte job to check. required Returns: Name Type Description job_status str The current status of the job. job_created_at str Datetime string of when the job was created. job_updated_at str Datetime string of the when the job was last updated. Source code in prefect_airbyte/client.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 async def get_job_status ( self , job_id : str ) -> Tuple [ str , str , str ]: \"\"\" Gets the status of an Airbyte connection sync job. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"get_job_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.trigger_manual_sync_connection","text":"Triggers a manual sync of the connection. Parameters: Name Type Description Default connection_id str ID of connection to sync. required Returns: Name Type Description job_id str ID of the job that was triggered. created_at str Datetime string of when the job was created. Source code in prefect_airbyte/client.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/sync/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"trigger_manual_sync_connection()"},{"location":"configuration/","text":"prefect_airbyte.configuration Tasks for updating and fetching Airbyte configurations Classes Functions export_configuration async Prefect Task that exports an Airbyte configuration via {airbyte_server_host}/api/v1/deployment/export . As of prefect-airbyte==0.1.3 , the kwargs airbyte_server_host and airbyte_server_port can be replaced by passing an airbyte_server block instance to generate the AirbyteClient . Using the airbyte_server block is preferred, but the individual kwargs remain for backwards compatibility. Parameters: Name Type Description Default airbyte_server Optional [ AirbyteServer ] An AirbyteServer block for generating an AirbyteClient . None airbyte_server_host Optional [ str ] Airbyte server host to connect to. None airbyte_server_port Optional [ int ] Airbyte server port to connect to. None airbyte_api_version Optional [ str ] Airbyte API version to use. None timeout int Timeout in seconds on the httpx.AsyncClient . 5 Returns: Type Description bytes Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere ( airbyte_configuration : bytes somewhere : str = 'my_destination.gz' , ' ): with gzip . open ( 'my_destination.gz' , 'wb' ) as f : f . write ( airbyte_configuration ) @flow def example_export_configuration_flow (): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server = AirbyteServer . load ( \"oss-airbyte\" ) ) zip_and_write_somewhere ( airbyte_config = airbyte_config ) example_trigger_sync_flow () Source code in prefect_airbyte/configuration.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @task async def export_configuration ( airbyte_server : Optional [ AirbyteServer ] = None , airbyte_server_host : Optional [ str ] = None , airbyte_server_port : Optional [ int ] = None , airbyte_api_version : Optional [ str ] = None , timeout : int = 5 , ) -> bytes : \"\"\" Prefect Task that exports an Airbyte configuration via `{airbyte_server_host}/api/v1/deployment/export`. As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and `airbyte_server_port` can be replaced by passing an `airbyte_server` block instance to generate the `AirbyteClient`. Using the `airbyte_server` block is preferred, but the individual kwargs remain for backwards compatibility. Args: airbyte_server: An `AirbyteServer` block for generating an `AirbyteClient`. airbyte_server_host: Airbyte server host to connect to. airbyte_server_port: Airbyte server port to connect to. airbyte_api_version: Airbyte API version to use. timeout: Timeout in seconds on the `httpx.AsyncClient`. Returns: Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: ```python import gzip from prefect import flow, task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere( airbyte_configuration: bytes somewhere: str = 'my_destination.gz',' ): with gzip.open('my_destination.gz', 'wb') as f: f.write(airbyte_configuration) @flow def example_export_configuration_flow(): # Run other tasks and subflows here airbyte_config = export_configuration( airbyte_server=AirbyteServer.load(\"oss-airbyte\") ) zip_and_write_somewhere(airbyte_config=airbyte_config) example_trigger_sync_flow() ``` \"\"\" logger = get_run_logger () if not airbyte_server : warn ( \"The use of `airbyte_server_host`, `airbyte_server_port`, and \" \"`airbyte_api_version` is deprecated and will be removed in a \" \"future release. Please pass an `airbyte_server` block to this \" \"task instead.\" , DeprecationWarning , stacklevel = 2 , ) if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): airbyte_server = AirbyteServer ( server_host = airbyte_server_host or \"localhost\" , server_port = airbyte_server_port or 8000 , api_version = airbyte_api_version or \"v1\" , ) else : airbyte_server = AirbyteServer () else : if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): logger . info ( \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \" \"and `airbyte_server_port` because `airbyte_server` block \" \" was passed. Using API URL from `airbyte_server` block: \" f \" { airbyte_server . base_url !r} .\" ) async with airbyte_server . get_client ( logger = logger , timeout = timeout ) as airbyte_client : logger . info ( \"Initiating export of Airbyte configuration\" ) return await airbyte_client . export_configuration ()","title":"Configuration"},{"location":"configuration/#prefect_airbyte.configuration","text":"Tasks for updating and fetching Airbyte configurations","title":"configuration"},{"location":"configuration/#prefect_airbyte.configuration-classes","text":"","title":"Classes"},{"location":"configuration/#prefect_airbyte.configuration-functions","text":"","title":"Functions"},{"location":"configuration/#prefect_airbyte.configuration.export_configuration","text":"Prefect Task that exports an Airbyte configuration via {airbyte_server_host}/api/v1/deployment/export . As of prefect-airbyte==0.1.3 , the kwargs airbyte_server_host and airbyte_server_port can be replaced by passing an airbyte_server block instance to generate the AirbyteClient . Using the airbyte_server block is preferred, but the individual kwargs remain for backwards compatibility. Parameters: Name Type Description Default airbyte_server Optional [ AirbyteServer ] An AirbyteServer block for generating an AirbyteClient . None airbyte_server_host Optional [ str ] Airbyte server host to connect to. None airbyte_server_port Optional [ int ] Airbyte server port to connect to. None airbyte_api_version Optional [ str ] Airbyte API version to use. None timeout int Timeout in seconds on the httpx.AsyncClient . 5 Returns: Type Description bytes Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere ( airbyte_configuration : bytes somewhere : str = 'my_destination.gz' , ' ): with gzip . open ( 'my_destination.gz' , 'wb' ) as f : f . write ( airbyte_configuration ) @flow def example_export_configuration_flow (): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server = AirbyteServer . load ( \"oss-airbyte\" ) ) zip_and_write_somewhere ( airbyte_config = airbyte_config ) example_trigger_sync_flow () Source code in prefect_airbyte/configuration.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @task async def export_configuration ( airbyte_server : Optional [ AirbyteServer ] = None , airbyte_server_host : Optional [ str ] = None , airbyte_server_port : Optional [ int ] = None , airbyte_api_version : Optional [ str ] = None , timeout : int = 5 , ) -> bytes : \"\"\" Prefect Task that exports an Airbyte configuration via `{airbyte_server_host}/api/v1/deployment/export`. As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and `airbyte_server_port` can be replaced by passing an `airbyte_server` block instance to generate the `AirbyteClient`. Using the `airbyte_server` block is preferred, but the individual kwargs remain for backwards compatibility. Args: airbyte_server: An `AirbyteServer` block for generating an `AirbyteClient`. airbyte_server_host: Airbyte server host to connect to. airbyte_server_port: Airbyte server port to connect to. airbyte_api_version: Airbyte API version to use. timeout: Timeout in seconds on the `httpx.AsyncClient`. Returns: Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: ```python import gzip from prefect import flow, task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere( airbyte_configuration: bytes somewhere: str = 'my_destination.gz',' ): with gzip.open('my_destination.gz', 'wb') as f: f.write(airbyte_configuration) @flow def example_export_configuration_flow(): # Run other tasks and subflows here airbyte_config = export_configuration( airbyte_server=AirbyteServer.load(\"oss-airbyte\") ) zip_and_write_somewhere(airbyte_config=airbyte_config) example_trigger_sync_flow() ``` \"\"\" logger = get_run_logger () if not airbyte_server : warn ( \"The use of `airbyte_server_host`, `airbyte_server_port`, and \" \"`airbyte_api_version` is deprecated and will be removed in a \" \"future release. Please pass an `airbyte_server` block to this \" \"task instead.\" , DeprecationWarning , stacklevel = 2 , ) if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): airbyte_server = AirbyteServer ( server_host = airbyte_server_host or \"localhost\" , server_port = airbyte_server_port or 8000 , api_version = airbyte_api_version or \"v1\" , ) else : airbyte_server = AirbyteServer () else : if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): logger . info ( \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \" \"and `airbyte_server_port` because `airbyte_server` block \" \" was passed. Using API URL from `airbyte_server` block: \" f \" { airbyte_server . base_url !r} .\" ) async with airbyte_server . get_client ( logger = logger , timeout = timeout ) as airbyte_client : logger . info ( \"Initiating export of Airbyte configuration\" ) return await airbyte_client . export_configuration ()","title":"export_configuration()"},{"location":"connections/","text":"prefect_airbyte.connections Tasks for connecting to Airbyte and triggering connection syncs Classes Functions trigger_sync async Prefect Task for triggering an Airbyte connection sync. It is assumed that the user will have previously configured a Source & Destination into a Connection. e.g. MySql -> CSV An invocation of trigger_sync will attempt to start a sync job for the specified connection_id representing the Connection in Airbyte. trigger_sync will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. As of prefect-airbyte==0.1.3 , the kwargs airbyte_server_host and airbyte_server_port can be replaced by passing an airbyte_server block instance to generate the AirbyteClient . Using the airbyte_server block is preferred, but the individual kwargs remain for backwards compatibility. Parameters: Name Type Description Default connection_id str Airbyte connection ID to trigger a sync for. required airbyte_server Optional [ AirbyteServer ] An AirbyteServer block to create an AirbyteClient . None airbyte_server_host Optional [ str ] Airbyte server host to connect to. None airbyte_server_port Optional [ int ] Airbyte server port to connect to. None airbyte_api_version Optional [ str ] Airbyte API version to use. None poll_interval_s int How often to poll Airbyte for sync status. 15 status_updates bool Whether to log sync job status while polling. False timeout int The POST request timeout for the httpx.AsyncClient . 5 Raises: Type Description ValueError If connection_id is not a valid UUID. err . AirbyteSyncJobFailed If airbyte returns JOB_STATUS_FAILED . err . AirbyteConnectionInactiveException If a given connection is inactive. err . AirbyeConnectionDeprecatedException If a given connection is deprecated. Returns: Type Description dict Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( airbyte_server = AirbyteServer . load ( \"oss-airbyte\" ), connection_id = \"your-connection-id-to-sync\" ) example_trigger_sync_flow () Source code in prefect_airbyte/connections.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @task async def trigger_sync ( connection_id : str , airbyte_server : Optional [ AirbyteServer ] = None , airbyte_server_host : Optional [ str ] = None , airbyte_server_port : Optional [ int ] = None , airbyte_api_version : Optional [ str ] = None , poll_interval_s : int = 15 , status_updates : bool = False , timeout : int = 5 , ) -> dict : \"\"\"Prefect Task for triggering an Airbyte connection sync. *It is assumed that the user will have previously configured a Source & Destination into a Connection.* e.g. MySql -> CSV An invocation of `trigger_sync` will attempt to start a sync job for the specified `connection_id` representing the Connection in Airbyte. `trigger_sync` will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and `airbyte_server_port` can be replaced by passing an `airbyte_server` block instance to generate the `AirbyteClient`. Using the `airbyte_server` block is preferred, but the individual kwargs remain for backwards compatibility. Args: connection_id: Airbyte connection ID to trigger a sync for. airbyte_server: An `AirbyteServer` block to create an `AirbyteClient`. airbyte_server_host: Airbyte server host to connect to. airbyte_server_port: Airbyte server port to connect to. airbyte_api_version: Airbyte API version to use. poll_interval_s: How often to poll Airbyte for sync status. status_updates: Whether to log sync job status while polling. timeout: The POST request `timeout` for the `httpx.AsyncClient`. Raises: ValueError: If `connection_id` is not a valid UUID. err.AirbyteSyncJobFailed: If airbyte returns `JOB_STATUS_FAILED`. err.AirbyteConnectionInactiveException: If a given connection is inactive. err.AirbyeConnectionDeprecatedException: If a given connection is deprecated. Returns: Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: ```python from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow(): # Run other tasks and subflows here trigger_sync( airbyte_server=AirbyteServer.load(\"oss-airbyte\"), connection_id=\"your-connection-id-to-sync\" ) example_trigger_sync_flow() ``` \"\"\" logger = get_run_logger () if not airbyte_server : warn ( \"The use of `airbyte_server_host`, `airbyte_server_port`, and \" \"`airbyte_api_version` is deprecated and will be removed in a \" \"future release. Please pass an `airbyte_server` block to this \" \"task instead.\" , DeprecationWarning , stacklevel = 2 , ) if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): airbyte_server = AirbyteServer ( server_host = airbyte_server_host or \"localhost\" , server_port = airbyte_server_port or 8000 , api_version = airbyte_api_version or \"v1\" , ) else : airbyte_server = AirbyteServer () else : if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): logger . info ( \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \" \"and `airbyte_server_port` because `airbyte_server` block \" \" was passed. Using API URL from `airbyte_server` block: \" f \" { airbyte_server . base_url !r} .\" ) try : uuid . UUID ( connection_id ) except ( TypeError , ValueError ): raise ValueError ( \"Parameter `connection_id` *must* be a valid UUID \\ i.e. 32 hex characters, including hyphens.\" ) async with airbyte_server . get_client ( logger = logger , timeout = timeout ) as airbyte_client : logger . info ( f \"Getting Airbyte Connection { connection_id } , poll interval \" f \" { poll_interval_s } seconds, airbyte_base_url { airbyte_server . base_url } \" ) connection_status = await airbyte_client . get_connection_status ( connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : # Trigger manual sync on the Connection ... ( job_id , job_created_at , ) = await airbyte_client . trigger_manual_sync_connection ( connection_id ) job_status = JOB_STATUS_PENDING while job_status not in [ JOB_STATUS_FAILED , JOB_STATUS_SUCCEEDED ]: ( job_status , job_created_at , job_updated_at , ) = await airbyte_client . get_job_status ( job_id ) # pending\u2503running\u2503incomplete\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : logger . info ( f \"Job { job_id } succeeded.\" ) elif job_status == JOB_STATUS_FAILED : logger . error ( f \"Job { job_id } failed.\" ) raise err . AirbyteSyncJobFailed ( f \"Job { job_id } failed.\" ) else : if status_updates : logger . info ( job_status ) # wait for next poll interval await sleep ( poll_interval_s ) return { \"connection_id\" : connection_id , \"status\" : connection_status , \"job_status\" : job_status , \"job_created_at\" : job_created_at , \"job_updated_at\" : job_updated_at , } elif connection_status == CONNECTION_STATUS_INACTIVE : logger . error ( f \"Connection: { connection_id } is inactive\" \" - you'll need to enable it in your Airbyte instance\" ) raise err . AirbyteConnectionInactiveException ( f \"Please enable the Connection { connection_id } in Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : logger . error ( f \"Connection { connection_id } is deprecated.\" ) raise err . AirbyeConnectionDeprecatedException ( f \"Connection { connection_id } is deprecated.\" )","title":"Connections"},{"location":"connections/#prefect_airbyte.connections","text":"Tasks for connecting to Airbyte and triggering connection syncs","title":"connections"},{"location":"connections/#prefect_airbyte.connections-classes","text":"","title":"Classes"},{"location":"connections/#prefect_airbyte.connections-functions","text":"","title":"Functions"},{"location":"connections/#prefect_airbyte.connections.trigger_sync","text":"Prefect Task for triggering an Airbyte connection sync. It is assumed that the user will have previously configured a Source & Destination into a Connection. e.g. MySql -> CSV An invocation of trigger_sync will attempt to start a sync job for the specified connection_id representing the Connection in Airbyte. trigger_sync will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. As of prefect-airbyte==0.1.3 , the kwargs airbyte_server_host and airbyte_server_port can be replaced by passing an airbyte_server block instance to generate the AirbyteClient . Using the airbyte_server block is preferred, but the individual kwargs remain for backwards compatibility. Parameters: Name Type Description Default connection_id str Airbyte connection ID to trigger a sync for. required airbyte_server Optional [ AirbyteServer ] An AirbyteServer block to create an AirbyteClient . None airbyte_server_host Optional [ str ] Airbyte server host to connect to. None airbyte_server_port Optional [ int ] Airbyte server port to connect to. None airbyte_api_version Optional [ str ] Airbyte API version to use. None poll_interval_s int How often to poll Airbyte for sync status. 15 status_updates bool Whether to log sync job status while polling. False timeout int The POST request timeout for the httpx.AsyncClient . 5 Raises: Type Description ValueError If connection_id is not a valid UUID. err . AirbyteSyncJobFailed If airbyte returns JOB_STATUS_FAILED . err . AirbyteConnectionInactiveException If a given connection is inactive. err . AirbyeConnectionDeprecatedException If a given connection is deprecated. Returns: Type Description dict Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( airbyte_server = AirbyteServer . load ( \"oss-airbyte\" ), connection_id = \"your-connection-id-to-sync\" ) example_trigger_sync_flow () Source code in prefect_airbyte/connections.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @task async def trigger_sync ( connection_id : str , airbyte_server : Optional [ AirbyteServer ] = None , airbyte_server_host : Optional [ str ] = None , airbyte_server_port : Optional [ int ] = None , airbyte_api_version : Optional [ str ] = None , poll_interval_s : int = 15 , status_updates : bool = False , timeout : int = 5 , ) -> dict : \"\"\"Prefect Task for triggering an Airbyte connection sync. *It is assumed that the user will have previously configured a Source & Destination into a Connection.* e.g. MySql -> CSV An invocation of `trigger_sync` will attempt to start a sync job for the specified `connection_id` representing the Connection in Airbyte. `trigger_sync` will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and `airbyte_server_port` can be replaced by passing an `airbyte_server` block instance to generate the `AirbyteClient`. Using the `airbyte_server` block is preferred, but the individual kwargs remain for backwards compatibility. Args: connection_id: Airbyte connection ID to trigger a sync for. airbyte_server: An `AirbyteServer` block to create an `AirbyteClient`. airbyte_server_host: Airbyte server host to connect to. airbyte_server_port: Airbyte server port to connect to. airbyte_api_version: Airbyte API version to use. poll_interval_s: How often to poll Airbyte for sync status. status_updates: Whether to log sync job status while polling. timeout: The POST request `timeout` for the `httpx.AsyncClient`. Raises: ValueError: If `connection_id` is not a valid UUID. err.AirbyteSyncJobFailed: If airbyte returns `JOB_STATUS_FAILED`. err.AirbyteConnectionInactiveException: If a given connection is inactive. err.AirbyeConnectionDeprecatedException: If a given connection is deprecated. Returns: Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: ```python from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow(): # Run other tasks and subflows here trigger_sync( airbyte_server=AirbyteServer.load(\"oss-airbyte\"), connection_id=\"your-connection-id-to-sync\" ) example_trigger_sync_flow() ``` \"\"\" logger = get_run_logger () if not airbyte_server : warn ( \"The use of `airbyte_server_host`, `airbyte_server_port`, and \" \"`airbyte_api_version` is deprecated and will be removed in a \" \"future release. Please pass an `airbyte_server` block to this \" \"task instead.\" , DeprecationWarning , stacklevel = 2 , ) if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): airbyte_server = AirbyteServer ( server_host = airbyte_server_host or \"localhost\" , server_port = airbyte_server_port or 8000 , api_version = airbyte_api_version or \"v1\" , ) else : airbyte_server = AirbyteServer () else : if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): logger . info ( \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \" \"and `airbyte_server_port` because `airbyte_server` block \" \" was passed. Using API URL from `airbyte_server` block: \" f \" { airbyte_server . base_url !r} .\" ) try : uuid . UUID ( connection_id ) except ( TypeError , ValueError ): raise ValueError ( \"Parameter `connection_id` *must* be a valid UUID \\ i.e. 32 hex characters, including hyphens.\" ) async with airbyte_server . get_client ( logger = logger , timeout = timeout ) as airbyte_client : logger . info ( f \"Getting Airbyte Connection { connection_id } , poll interval \" f \" { poll_interval_s } seconds, airbyte_base_url { airbyte_server . base_url } \" ) connection_status = await airbyte_client . get_connection_status ( connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : # Trigger manual sync on the Connection ... ( job_id , job_created_at , ) = await airbyte_client . trigger_manual_sync_connection ( connection_id ) job_status = JOB_STATUS_PENDING while job_status not in [ JOB_STATUS_FAILED , JOB_STATUS_SUCCEEDED ]: ( job_status , job_created_at , job_updated_at , ) = await airbyte_client . get_job_status ( job_id ) # pending\u2503running\u2503incomplete\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : logger . info ( f \"Job { job_id } succeeded.\" ) elif job_status == JOB_STATUS_FAILED : logger . error ( f \"Job { job_id } failed.\" ) raise err . AirbyteSyncJobFailed ( f \"Job { job_id } failed.\" ) else : if status_updates : logger . info ( job_status ) # wait for next poll interval await sleep ( poll_interval_s ) return { \"connection_id\" : connection_id , \"status\" : connection_status , \"job_status\" : job_status , \"job_created_at\" : job_created_at , \"job_updated_at\" : job_updated_at , } elif connection_status == CONNECTION_STATUS_INACTIVE : logger . error ( f \"Connection: { connection_id } is inactive\" \" - you'll need to enable it in your Airbyte instance\" ) raise err . AirbyteConnectionInactiveException ( f \"Please enable the Connection { connection_id } in Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : logger . error ( f \"Connection { connection_id } is deprecated.\" ) raise err . AirbyeConnectionDeprecatedException ( f \"Connection { connection_id } is deprecated.\" )","title":"trigger_sync()"},{"location":"server/","text":"prefect_airbyte.server A module for defining OSS Airbyte interactions with Prefect. Classes AirbyteServer Bases: Block A block representing an Airbyte server for generating AirbyteClient instances. Attributes: Name Type Description username str Username for Airbyte API. password SecretStr Password for Airbyte API. server_host str Hostname for Airbyte API. server_port int Port for Airbyte API. api_version str Version of Airbyte API to use. use_ssl bool Whether to use a secure url for calls to the Airbyte API. Example Create an AirbyteServer block for an Airbyte instance running on localhost: from prefect import flow from prefect_airbyte.connection import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def airbyte_orchestration_flow (): airbyte_server = AirbyteServer () trigger_sync ( airbyte_server = airbyte_server , connection_id = \"my_connection_id\" , ) Source code in prefect_airbyte/server.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class AirbyteServer ( Block ): \"\"\"A block representing an Airbyte server for generating `AirbyteClient` instances. Attributes: username: Username for Airbyte API. password: Password for Airbyte API. server_host: Hostname for Airbyte API. server_port: Port for Airbyte API. api_version: Version of Airbyte API to use. use_ssl: Whether to use a secure url for calls to the Airbyte API. Example: Create an `AirbyteServer` block for an Airbyte instance running on localhost: ```python from prefect import flow from prefect_airbyte.connection import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def airbyte_orchestration_flow(): airbyte_server = AirbyteServer() trigger_sync( airbyte_server=airbyte_server, connection_id=\"my_connection_id\", ) ``` \"\"\" _block_type_name = \"Airbyte Server\" _block_type_slug = \"airbyte-server\" _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/6gm7wsC7ANnKYQsm7oiSYz/aac1ad5e054d35d9e24af8d6ed3aed5f/59758427?h=250\" # noqa username : str = Field ( default = \"airbyte\" , description = \"Username to authenticate with Airbyte API.\" , ) password : SecretStr = Field ( default = SecretStr ( \"password\" ), description = \"Password to authenticate with Airbyte API.\" , ) server_host : str = Field ( default = \"localhost\" , description = \"Host address of Airbyte server.\" , example = \"127.0.0.1\" , ) server_port : int = Field ( default = 8000 , description = \"Port number of Airbyte server.\" , ) api_version : str = Field ( default = \"v1\" , description = \"Airbyte API version to use.\" , title = \"API Version\" , ) use_ssl : bool = Field ( default = False , description = \"Whether to use SSL when connecting to Airbyte server.\" , title = \"Use SSL\" , ) @property def base_url ( self ) -> str : \"\"\"Property containing the base URL for the Airbyte API.\"\"\" protocol = \"https\" if self . use_ssl else \"http\" return ( f \" { protocol } :// { self . server_host } : { self . server_port } /api/ { self . api_version } \" ) def get_client ( self , logger : Logger , timeout : int = 10 ) -> AirbyteClient : \"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API. Args: logger: Logger instance used to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. Returns: An `AirbyteClient` instance. \"\"\" return AirbyteClient ( logger = logger , airbyte_base_url = self . base_url , auth = ( self . username , self . password . get_secret_value ()), timeout = timeout , ) Functions base_url property Property containing the base URL for the Airbyte API. Source code in prefect_airbyte/server.py 76 77 78 79 80 81 82 @property def base_url ( self ) -> str : \"\"\"Property containing the base URL for the Airbyte API.\"\"\" protocol = \"https\" if self . use_ssl else \"http\" return ( f \" { protocol } :// { self . server_host } : { self . server_port } /api/ { self . api_version } \" ) get_client Returns an AirbyteClient instance for interacting with the Airbyte API. Parameters: Name Type Description Default logger Logger Logger instance used to log messages related to API calls. required timeout int The number of seconds to wait before an API call times out. 10 Returns: Type Description AirbyteClient An AirbyteClient instance. Source code in prefect_airbyte/server.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_client ( self , logger : Logger , timeout : int = 10 ) -> AirbyteClient : \"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API. Args: logger: Logger instance used to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. Returns: An `AirbyteClient` instance. \"\"\" return AirbyteClient ( logger = logger , airbyte_base_url = self . base_url , auth = ( self . username , self . password . get_secret_value ()), timeout = timeout , )","title":"Server"},{"location":"server/#prefect_airbyte.server","text":"A module for defining OSS Airbyte interactions with Prefect.","title":"server"},{"location":"server/#prefect_airbyte.server-classes","text":"","title":"Classes"},{"location":"server/#prefect_airbyte.server.AirbyteServer","text":"Bases: Block A block representing an Airbyte server for generating AirbyteClient instances. Attributes: Name Type Description username str Username for Airbyte API. password SecretStr Password for Airbyte API. server_host str Hostname for Airbyte API. server_port int Port for Airbyte API. api_version str Version of Airbyte API to use. use_ssl bool Whether to use a secure url for calls to the Airbyte API. Example Create an AirbyteServer block for an Airbyte instance running on localhost: from prefect import flow from prefect_airbyte.connection import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def airbyte_orchestration_flow (): airbyte_server = AirbyteServer () trigger_sync ( airbyte_server = airbyte_server , connection_id = \"my_connection_id\" , ) Source code in prefect_airbyte/server.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class AirbyteServer ( Block ): \"\"\"A block representing an Airbyte server for generating `AirbyteClient` instances. Attributes: username: Username for Airbyte API. password: Password for Airbyte API. server_host: Hostname for Airbyte API. server_port: Port for Airbyte API. api_version: Version of Airbyte API to use. use_ssl: Whether to use a secure url for calls to the Airbyte API. Example: Create an `AirbyteServer` block for an Airbyte instance running on localhost: ```python from prefect import flow from prefect_airbyte.connection import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def airbyte_orchestration_flow(): airbyte_server = AirbyteServer() trigger_sync( airbyte_server=airbyte_server, connection_id=\"my_connection_id\", ) ``` \"\"\" _block_type_name = \"Airbyte Server\" _block_type_slug = \"airbyte-server\" _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/6gm7wsC7ANnKYQsm7oiSYz/aac1ad5e054d35d9e24af8d6ed3aed5f/59758427?h=250\" # noqa username : str = Field ( default = \"airbyte\" , description = \"Username to authenticate with Airbyte API.\" , ) password : SecretStr = Field ( default = SecretStr ( \"password\" ), description = \"Password to authenticate with Airbyte API.\" , ) server_host : str = Field ( default = \"localhost\" , description = \"Host address of Airbyte server.\" , example = \"127.0.0.1\" , ) server_port : int = Field ( default = 8000 , description = \"Port number of Airbyte server.\" , ) api_version : str = Field ( default = \"v1\" , description = \"Airbyte API version to use.\" , title = \"API Version\" , ) use_ssl : bool = Field ( default = False , description = \"Whether to use SSL when connecting to Airbyte server.\" , title = \"Use SSL\" , ) @property def base_url ( self ) -> str : \"\"\"Property containing the base URL for the Airbyte API.\"\"\" protocol = \"https\" if self . use_ssl else \"http\" return ( f \" { protocol } :// { self . server_host } : { self . server_port } /api/ { self . api_version } \" ) def get_client ( self , logger : Logger , timeout : int = 10 ) -> AirbyteClient : \"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API. Args: logger: Logger instance used to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. Returns: An `AirbyteClient` instance. \"\"\" return AirbyteClient ( logger = logger , airbyte_base_url = self . base_url , auth = ( self . username , self . password . get_secret_value ()), timeout = timeout , )","title":"AirbyteServer"},{"location":"server/#prefect_airbyte.server.AirbyteServer-functions","text":"","title":"Functions"},{"location":"server/#prefect_airbyte.server.AirbyteServer.base_url","text":"Property containing the base URL for the Airbyte API. Source code in prefect_airbyte/server.py 76 77 78 79 80 81 82 @property def base_url ( self ) -> str : \"\"\"Property containing the base URL for the Airbyte API.\"\"\" protocol = \"https\" if self . use_ssl else \"http\" return ( f \" { protocol } :// { self . server_host } : { self . server_port } /api/ { self . api_version } \" )","title":"base_url()"},{"location":"server/#prefect_airbyte.server.AirbyteServer.get_client","text":"Returns an AirbyteClient instance for interacting with the Airbyte API. Parameters: Name Type Description Default logger Logger Logger instance used to log messages related to API calls. required timeout int The number of seconds to wait before an API call times out. 10 Returns: Type Description AirbyteClient An AirbyteClient instance. Source code in prefect_airbyte/server.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_client ( self , logger : Logger , timeout : int = 10 ) -> AirbyteClient : \"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API. Args: logger: Logger instance used to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. Returns: An `AirbyteClient` instance. \"\"\" return AirbyteClient ( logger = logger , airbyte_base_url = self . base_url , auth = ( self . username , self . password . get_secret_value ()), timeout = timeout , )","title":"get_client()"}]}