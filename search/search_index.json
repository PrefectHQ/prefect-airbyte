{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"prefect-airbyte Welcome! prefect-airbyte is a collection of prebuilt Prefect tasks that can be used to quickly construct Prefect flows to trigger Airbyte syncs or export your connector configurations. Getting Started Python setup Requires an installation of Python 3.7+ We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation . Installation Install prefect-airbyte pip install prefect-airbyte Airbyte setup See the airbyte documention on how to get your own instance. Examples Trigger a defined connection sync from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( connection_id = \"your-connection-id-to-sync\" , poll_interval_s = 3 , status_updates = True ) example_trigger_sync_flow () \u276f python airbyte_syncs.py 03:46:03 | prefect.engine - Created flow run 'thick-seahorse' for flow 'example_trigger_sync_flow' 03:46:03 | Flow run 'thick-seahorse' - Using task runner 'ConcurrentTaskRunner' 03:46:03 | Flow run 'thick-seahorse' - Created task run 'trigger_sync-35f0e9c2-0' for task 'trigger_sync' 03:46:03 | prefect - trigger airbyte connection: e1b2078f-882a-4f50-9942-cfe34b2d825b, poll interval 3 seconds 03:46:03 | prefect - pending 03:46:06 | prefect - running 03:46:09 | prefect - running 03:46:12 | prefect - running 03:46:16 | prefect - running 03:46:19 | prefect - running 03:46:22 | prefect - Job 26 succeeded. 03:46:22 | Task run 'trigger_sync-35f0e9c2-0' - Finished in state Completed(None) 03:46:22 | Flow run 'thick-seahorse' - Finished in state Completed('All states completed.') Export an Airbyte instance's configuration import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere ( airbyte_config : bytearray , somewhere : str , ): with gzip . open ( somewhere , 'wb' ) as f : f . write ( airbyte_config ) @flow def example_export_configuration_flow ( filepath : str ): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server_host = \"localhost\" , airbyte_server_port = \"8000\" , airbyte_api_version = \"v1\" , ) zip_and_write_somewhere ( somewhere = filepath , airbyte_config = airbyte_config ) if __name__ == \"__main__\" : example_export_configuration_flow ( '*://**/my_destination.gz' ) Resources If you encounter and bugs while using prefect-airbyte , feel free to open an issue in the prefect-airbyte repository. If you have any questions or issues while using prefect-airbyte , you can find help in either the Prefect Discourse forum or the Prefect Slack community Development If you'd like to install a version of prefect-airbyte for development, first clone the repository and then perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-airbyte.git cd prefect-airbyte/ pip install -e \".[dev]\"","title":"Home"},{"location":"#prefect-airbyte","text":"","title":"prefect-airbyte"},{"location":"#welcome","text":"prefect-airbyte is a collection of prebuilt Prefect tasks that can be used to quickly construct Prefect flows to trigger Airbyte syncs or export your connector configurations.","title":"Welcome!"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#python-setup","text":"Requires an installation of Python 3.7+ We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation .","title":"Python setup"},{"location":"#installation","text":"Install prefect-airbyte pip install prefect-airbyte","title":"Installation"},{"location":"#airbyte-setup","text":"See the airbyte documention on how to get your own instance.","title":"Airbyte setup"},{"location":"#examples","text":"","title":"Examples"},{"location":"#trigger-a-defined-connection-sync","text":"from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( connection_id = \"your-connection-id-to-sync\" , poll_interval_s = 3 , status_updates = True ) example_trigger_sync_flow () \u276f python airbyte_syncs.py 03:46:03 | prefect.engine - Created flow run 'thick-seahorse' for flow 'example_trigger_sync_flow' 03:46:03 | Flow run 'thick-seahorse' - Using task runner 'ConcurrentTaskRunner' 03:46:03 | Flow run 'thick-seahorse' - Created task run 'trigger_sync-35f0e9c2-0' for task 'trigger_sync' 03:46:03 | prefect - trigger airbyte connection: e1b2078f-882a-4f50-9942-cfe34b2d825b, poll interval 3 seconds 03:46:03 | prefect - pending 03:46:06 | prefect - running 03:46:09 | prefect - running 03:46:12 | prefect - running 03:46:16 | prefect - running 03:46:19 | prefect - running 03:46:22 | prefect - Job 26 succeeded. 03:46:22 | Task run 'trigger_sync-35f0e9c2-0' - Finished in state Completed(None) 03:46:22 | Flow run 'thick-seahorse' - Finished in state Completed('All states completed.')","title":"Trigger a defined connection sync"},{"location":"#export-an-airbyte-instances-configuration","text":"import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere ( airbyte_config : bytearray , somewhere : str , ): with gzip . open ( somewhere , 'wb' ) as f : f . write ( airbyte_config ) @flow def example_export_configuration_flow ( filepath : str ): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server_host = \"localhost\" , airbyte_server_port = \"8000\" , airbyte_api_version = \"v1\" , ) zip_and_write_somewhere ( somewhere = filepath , airbyte_config = airbyte_config ) if __name__ == \"__main__\" : example_export_configuration_flow ( '*://**/my_destination.gz' )","title":"Export an Airbyte instance's configuration"},{"location":"#resources","text":"If you encounter and bugs while using prefect-airbyte , feel free to open an issue in the prefect-airbyte repository. If you have any questions or issues while using prefect-airbyte , you can find help in either the Prefect Discourse forum or the Prefect Slack community","title":"Resources"},{"location":"#development","text":"If you'd like to install a version of prefect-airbyte for development, first clone the repository and then perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-airbyte.git cd prefect-airbyte/ pip install -e \".[dev]\"","title":"Development"},{"location":"client/","text":"prefect_airbyte.client Client for interacting with Airbyte instance AirbyteClient Client class used to call API endpoints on an Airbyte server. This client assumes that you're using an OSS Airbyte server which does not require an API key to access its a API. For more info, see the Airbyte docs . Attributes: Name Type Description logger A logger instance used by the client to log messages related to API calls. airbyte_base_url str Base API endpoint URL for Airbyte. timeout The number of seconds to wait before an API call times out. Source code in prefect_airbyte/client.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class AirbyteClient : \"\"\" Client class used to call API endpoints on an Airbyte server. This client assumes that you're using an OSS Airbyte server which does not require an API key to access its a API. For more info, see the [Airbyte docs](https://docs.airbyte.io/api-documentation). Attributes: logger: A logger instance used by the client to log messages related to API calls. airbyte_base_url str: Base API endpoint URL for Airbyte. timeout: The number of seconds to wait before an API call times out. \"\"\" def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , timeout : int = 5 , ): self . airbyte_base_url = airbyte_base_url self . logger = logger self . timeout = timeout async def _establish_session ( self ) -> httpx . AsyncClient : \"\"\" Checks health of the Airbyte server and establishes a session. Returns: Session used to communicate with the Airbyte API. \"\"\" client = httpx . AsyncClient ( timeout = self . timeout ) await self . check_health_status ( client ) return client async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an AirbyteInstance. Args: Session used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e async def create_client ( self ) -> httpx . AsyncClient : \"\"\" Convenience method for establishing a healthy session with the Airbyte server. Returns: Session for interacting with the Airbyte server. \"\"\" client = await self . _establish_session () return client async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. Returns: Gzipped Airbyte configuration data. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : raise err . AirbyteExportConfigurationFailed () from e async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/get/\" # TODO - Missing auth because Airbyte API currently doesn't yet support auth try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/sync/\" # TODO - no current authentication methods from Airbyte try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def get_job_status ( self , job_id : str ) -> Tuple [ str , str , str ]: \"\"\" Gets the status of an Airbyte connection sync job. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e check_health_status async Checks the health status of an AirbyteInstance. Returns: Type Description bool True if the server is healthy. False otherwise. Source code in prefect_airbyte/client.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an AirbyteInstance. Args: Session used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e create_client async Convenience method for establishing a healthy session with the Airbyte server. Returns: Type Description httpx . AsyncClient Session for interacting with the Airbyte server. Source code in prefect_airbyte/client.py 74 75 76 77 78 79 80 81 82 async def create_client ( self ) -> httpx . AsyncClient : \"\"\" Convenience method for establishing a healthy session with the Airbyte server. Returns: Session for interacting with the Airbyte server. \"\"\" client = await self . _establish_session () return client export_configuration async Triggers an export of Airbyte configuration. Returns: Type Description bytes Gzipped Airbyte configuration data. Source code in prefect_airbyte/client.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. Returns: Gzipped Airbyte configuration data. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : raise err . AirbyteExportConfigurationFailed () from e get_connection_status async Gets the status of a defined Airbyte connection. Parameters: Name Type Description Default connection_id str ID of an existing Airbyte connection. required Returns: Type Description str The status of the defined Airbyte connection. Source code in prefect_airbyte/client.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/get/\" # TODO - Missing auth because Airbyte API currently doesn't yet support auth try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e get_job_status async Gets the status of an Airbyte connection sync job. Parameters: Name Type Description Default job_id str ID of the Airbyte job to check. required Returns: Name Type Description job_status str The current status of the job. job_created_at str Datetime string of when the job was created. job_updated_at str Datetime string of the when the job was last updated. Source code in prefect_airbyte/client.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 async def get_job_status ( self , job_id : str ) -> Tuple [ str , str , str ]: \"\"\" Gets the status of an Airbyte connection sync job. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e trigger_manual_sync_connection async Triggers a manual sync of the connection. Parameters: Name Type Description Default connection_id str ID of connection to sync. required Returns: Name Type Description job_id str ID of the job that was triggered. created_at str Datetime string of when the job was created. Source code in prefect_airbyte/client.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/sync/\" # TODO - no current authentication methods from Airbyte try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"Client"},{"location":"client/#prefect_airbyte.client","text":"Client for interacting with Airbyte instance","title":"client"},{"location":"client/#prefect_airbyte.client.AirbyteClient","text":"Client class used to call API endpoints on an Airbyte server. This client assumes that you're using an OSS Airbyte server which does not require an API key to access its a API. For more info, see the Airbyte docs . Attributes: Name Type Description logger A logger instance used by the client to log messages related to API calls. airbyte_base_url str Base API endpoint URL for Airbyte. timeout The number of seconds to wait before an API call times out. Source code in prefect_airbyte/client.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class AirbyteClient : \"\"\" Client class used to call API endpoints on an Airbyte server. This client assumes that you're using an OSS Airbyte server which does not require an API key to access its a API. For more info, see the [Airbyte docs](https://docs.airbyte.io/api-documentation). Attributes: logger: A logger instance used by the client to log messages related to API calls. airbyte_base_url str: Base API endpoint URL for Airbyte. timeout: The number of seconds to wait before an API call times out. \"\"\" def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , timeout : int = 5 , ): self . airbyte_base_url = airbyte_base_url self . logger = logger self . timeout = timeout async def _establish_session ( self ) -> httpx . AsyncClient : \"\"\" Checks health of the Airbyte server and establishes a session. Returns: Session used to communicate with the Airbyte API. \"\"\" client = httpx . AsyncClient ( timeout = self . timeout ) await self . check_health_status ( client ) return client async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an AirbyteInstance. Args: Session used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e async def create_client ( self ) -> httpx . AsyncClient : \"\"\" Convenience method for establishing a healthy session with the Airbyte server. Returns: Session for interacting with the Airbyte server. \"\"\" client = await self . _establish_session () return client async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. Returns: Gzipped Airbyte configuration data. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : raise err . AirbyteExportConfigurationFailed () from e async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/get/\" # TODO - Missing auth because Airbyte API currently doesn't yet support auth try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/sync/\" # TODO - no current authentication methods from Airbyte try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def get_job_status ( self , job_id : str ) -> Tuple [ str , str , str ]: \"\"\" Gets the status of an Airbyte connection sync job. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"AirbyteClient"},{"location":"client/#prefect_airbyte.client.AirbyteClient.check_health_status","text":"Checks the health status of an AirbyteInstance. Returns: Type Description bool True if the server is healthy. False otherwise. Source code in prefect_airbyte/client.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an AirbyteInstance. Args: Session used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e","title":"check_health_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.create_client","text":"Convenience method for establishing a healthy session with the Airbyte server. Returns: Type Description httpx . AsyncClient Session for interacting with the Airbyte server. Source code in prefect_airbyte/client.py 74 75 76 77 78 79 80 81 82 async def create_client ( self ) -> httpx . AsyncClient : \"\"\" Convenience method for establishing a healthy session with the Airbyte server. Returns: Session for interacting with the Airbyte server. \"\"\" client = await self . _establish_session () return client","title":"create_client()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.export_configuration","text":"Triggers an export of Airbyte configuration. Returns: Type Description bytes Gzipped Airbyte configuration data. Source code in prefect_airbyte/client.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. Returns: Gzipped Airbyte configuration data. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : raise err . AirbyteExportConfigurationFailed () from e","title":"export_configuration()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_connection_status","text":"Gets the status of a defined Airbyte connection. Parameters: Name Type Description Default connection_id str ID of an existing Airbyte connection. required Returns: Type Description str The status of the defined Airbyte connection. Source code in prefect_airbyte/client.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/get/\" # TODO - Missing auth because Airbyte API currently doesn't yet support auth try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e","title":"get_connection_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_job_status","text":"Gets the status of an Airbyte connection sync job. Parameters: Name Type Description Default job_id str ID of the Airbyte job to check. required Returns: Name Type Description job_status str The current status of the job. job_created_at str Datetime string of when the job was created. job_updated_at str Datetime string of the when the job was last updated. Source code in prefect_airbyte/client.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 async def get_job_status ( self , job_id : str ) -> Tuple [ str , str , str ]: \"\"\" Gets the status of an Airbyte connection sync job. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"get_job_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.trigger_manual_sync_connection","text":"Triggers a manual sync of the connection. Parameters: Name Type Description Default connection_id str ID of connection to sync. required Returns: Name Type Description job_id str ID of the job that was triggered. created_at str Datetime string of when the job was created. Source code in prefect_airbyte/client.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/sync/\" # TODO - no current authentication methods from Airbyte try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"trigger_manual_sync_connection()"},{"location":"configuration/","text":"prefect_airbyte.configuration Tasks for updating and fetching Airbyte configurations export_configuration async Prefect Task that exports an Airbyte configuration via {airbyte_server_host}/api/v1/deployment/export . Parameters: Name Type Description Default airbyte_server_host str Airbyte instance hostname where connection is configured. 'localhost' airbyte_server_port int Port where Airbyte instance is listening. '8000' airbyte_api_version str Version of Airbyte API to use to export configuration. 'v1' timeout int Timeout in seconds on the httpx.AsyncClient . 5 Returns: Type Description bytes Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere ( airbyte_configuration : bytes somewhere : str = 'my_destination.gz' , ' ): with gzip . open ( 'my_destination.gz' , 'wb' ) as f : f . write ( airbyte_configuration ) @flow def example_export_configuration_flow (): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server_host = \"localhost\" , airbyte_server_port = \"8000\" , airbyte_api_version = \"v1\" , ) zip_and_write_somewhere ( airbyte_config = airbyte_config ) example_trigger_sync_flow () Source code in prefect_airbyte/configuration.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @task async def export_configuration ( airbyte_server_host : str = \"localhost\" , airbyte_server_port : int = \"8000\" , airbyte_api_version : str = \"v1\" , timeout : int = 5 , ) -> bytes : \"\"\" Prefect Task that exports an Airbyte configuration via `{airbyte_server_host}/api/v1/deployment/export`. Args: airbyte_server_host: Airbyte instance hostname where connection is configured. airbyte_server_port: Port where Airbyte instance is listening. airbyte_api_version: Version of Airbyte API to use to export configuration. timeout: Timeout in seconds on the `httpx.AsyncClient`. Returns: Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: ```python import gzip from prefect import flow, task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere( airbyte_configuration: bytes somewhere: str = 'my_destination.gz',' ): with gzip.open('my_destination.gz', 'wb') as f: f.write(airbyte_configuration) @flow def example_export_configuration_flow(): # Run other tasks and subflows here airbyte_config = export_configuration( airbyte_server_host=\"localhost\", airbyte_server_port=\"8000\", airbyte_api_version=\"v1\", ) zip_and_write_somewhere(airbyte_config=airbyte_config) example_trigger_sync_flow() ``` \"\"\" logger = get_logger () airbyte_base_url = ( f \"http:// { airbyte_server_host } :\" f \" { airbyte_server_port } /api/ { airbyte_api_version } \" ) airbyte = AirbyteClient ( logger , airbyte_base_url , timeout = timeout ) logger . info ( \"Initiating export of Airbyte configuration\" ) airbyte_config = await airbyte . export_configuration () return airbyte_config","title":"Configuration"},{"location":"configuration/#prefect_airbyte.configuration","text":"Tasks for updating and fetching Airbyte configurations","title":"configuration"},{"location":"configuration/#prefect_airbyte.configuration.export_configuration","text":"Prefect Task that exports an Airbyte configuration via {airbyte_server_host}/api/v1/deployment/export . Parameters: Name Type Description Default airbyte_server_host str Airbyte instance hostname where connection is configured. 'localhost' airbyte_server_port int Port where Airbyte instance is listening. '8000' airbyte_api_version str Version of Airbyte API to use to export configuration. 'v1' timeout int Timeout in seconds on the httpx.AsyncClient . 5 Returns: Type Description bytes Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere ( airbyte_configuration : bytes somewhere : str = 'my_destination.gz' , ' ): with gzip . open ( 'my_destination.gz' , 'wb' ) as f : f . write ( airbyte_configuration ) @flow def example_export_configuration_flow (): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server_host = \"localhost\" , airbyte_server_port = \"8000\" , airbyte_api_version = \"v1\" , ) zip_and_write_somewhere ( airbyte_config = airbyte_config ) example_trigger_sync_flow () Source code in prefect_airbyte/configuration.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @task async def export_configuration ( airbyte_server_host : str = \"localhost\" , airbyte_server_port : int = \"8000\" , airbyte_api_version : str = \"v1\" , timeout : int = 5 , ) -> bytes : \"\"\" Prefect Task that exports an Airbyte configuration via `{airbyte_server_host}/api/v1/deployment/export`. Args: airbyte_server_host: Airbyte instance hostname where connection is configured. airbyte_server_port: Port where Airbyte instance is listening. airbyte_api_version: Version of Airbyte API to use to export configuration. timeout: Timeout in seconds on the `httpx.AsyncClient`. Returns: Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: ```python import gzip from prefect import flow, task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere( airbyte_configuration: bytes somewhere: str = 'my_destination.gz',' ): with gzip.open('my_destination.gz', 'wb') as f: f.write(airbyte_configuration) @flow def example_export_configuration_flow(): # Run other tasks and subflows here airbyte_config = export_configuration( airbyte_server_host=\"localhost\", airbyte_server_port=\"8000\", airbyte_api_version=\"v1\", ) zip_and_write_somewhere(airbyte_config=airbyte_config) example_trigger_sync_flow() ``` \"\"\" logger = get_logger () airbyte_base_url = ( f \"http:// { airbyte_server_host } :\" f \" { airbyte_server_port } /api/ { airbyte_api_version } \" ) airbyte = AirbyteClient ( logger , airbyte_base_url , timeout = timeout ) logger . info ( \"Initiating export of Airbyte configuration\" ) airbyte_config = await airbyte . export_configuration () return airbyte_config","title":"export_configuration()"},{"location":"connections/","text":"prefect_airbyte.connections Tasks for connecting to Airbyte and triggering connection syncs trigger_sync async Prefect Task for triggering an Airbyte connection sync. It is assumed that the user will have previously configured a Source & Destination into a Connection. e.g. MySql -> CSV An invocation of trigger_sync will attempt to start a sync job for the specified connection_id representing the Connection in Airbyte. trigger_sync will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. Parameters: Name Type Description Default connection_id str Airbyte connection ID to trigger a sync for. required airbyte_server_host str Airbyte instance hostname where connection is configured. 'localhost' airbyte_server_port int Port where Airbyte instance is listening. '8000' airbyte_api_version str Version of Airbyte API to use to trigger connection sync. 'v1' poll_interval_s int How often to poll Airbyte for sync status. 15 status_updates bool Whether to log sync job status while polling. False timeout int The POST request timeout for the httpx.AsyncClient . 5 Raises: Type Description ValueError If connection_id is not a valid UUID. err . AirbyteSyncJobFailed If airbyte returns JOB_STATUS_FAILED . err . AirbyteConnectionInactiveException If a given connection is inactive. err . AirbyeConnectionDeprecatedException If a given connection is deprecated. Returns: Type Description dict Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( connection_id = \"your-connection-id-to-sync\" ) example_trigger_sync_flow () Source code in prefect_airbyte/connections.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 @task async def trigger_sync ( connection_id : str , airbyte_server_host : str = \"localhost\" , airbyte_server_port : int = \"8000\" , airbyte_api_version : str = \"v1\" , poll_interval_s : int = 15 , status_updates : bool = False , timeout : int = 5 , ) -> dict : \"\"\"Prefect Task for triggering an Airbyte connection sync. *It is assumed that the user will have previously configured a Source & Destination into a Connection.* e.g. MySql -> CSV An invocation of `trigger_sync` will attempt to start a sync job for the specified `connection_id` representing the Connection in Airbyte. `trigger_sync` will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. Args: connection_id: Airbyte connection ID to trigger a sync for. airbyte_server_host: Airbyte instance hostname where connection is configured. airbyte_server_port: Port where Airbyte instance is listening. airbyte_api_version: Version of Airbyte API to use to trigger connection sync. poll_interval_s: How often to poll Airbyte for sync status. status_updates: Whether to log sync job status while polling. timeout: The POST request `timeout` for the `httpx.AsyncClient`. Raises: ValueError: If `connection_id` is not a valid UUID. err.AirbyteSyncJobFailed: If airbyte returns `JOB_STATUS_FAILED`. err.AirbyteConnectionInactiveException: If a given connection is inactive. err.AirbyeConnectionDeprecatedException: If a given connection is deprecated. Returns: Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: ```python from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow(): # Run other tasks and subflows here trigger_sync( connection_id=\"your-connection-id-to-sync\" ) example_trigger_sync_flow() ``` \"\"\" logger = get_logger () try : uuid . UUID ( connection_id ) except ( TypeError , ValueError ): raise ValueError ( \"Parameter `connection_id` *must* be a valid UUID \\ i.e. 32 hex characters, including hyphens.\" ) # see https://airbyte-public-api-docs.s3.us-east-2.amazonaws.com # /rapidoc-api-docs.html#overview airbyte_base_url = ( f \"http:// { airbyte_server_host } :\" f \" { airbyte_server_port } /api/ { airbyte_api_version } \" ) airbyte = AirbyteClient ( logger , airbyte_base_url , timeout = timeout ) logger . info ( f \"Getting Airbyte Connection { connection_id } , poll interval \" f \" { poll_interval_s } seconds, airbyte_base_url { airbyte_base_url } \" ) connection_status = await airbyte . get_connection_status ( connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : # Trigger manual sync on the Connection ... job_id , job_created_at = await airbyte . trigger_manual_sync_connection ( connection_id ) job_status = JOB_STATUS_PENDING while job_status not in [ JOB_STATUS_FAILED , JOB_STATUS_SUCCEEDED ]: job_status , job_created_at , job_updated_at = await airbyte . get_job_status ( job_id ) # pending\u2503running\u2503incomplete\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : logger . info ( f \"Job { job_id } succeeded.\" ) elif job_status == JOB_STATUS_FAILED : logger . error ( f \"Job { job_id } failed.\" ) raise err . AirbyteSyncJobFailed ( f \"Job { job_id } failed.\" ) else : if status_updates : logger . info ( job_status ) # wait for next poll interval await sleep ( poll_interval_s ) return { \"connection_id\" : connection_id , \"status\" : connection_status , \"job_status\" : job_status , \"job_created_at\" : job_created_at , \"job_updated_at\" : job_updated_at , } elif connection_status == CONNECTION_STATUS_INACTIVE : logger . error ( f \"Connection: { connection_id } is inactive\" \" - you'll need to enable it in your Airbyte instance\" ) raise err . AirbyteConnectionInactiveException ( f \"Please enable the Connection { connection_id } in Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : logger . error ( f \"Connection { connection_id } is deprecated.\" ) raise err . AirbyeConnectionDeprecatedException ( f \"Connection { connection_id } is deprecated.\" )","title":"Connections"},{"location":"connections/#prefect_airbyte.connections","text":"Tasks for connecting to Airbyte and triggering connection syncs","title":"connections"},{"location":"connections/#prefect_airbyte.connections.trigger_sync","text":"Prefect Task for triggering an Airbyte connection sync. It is assumed that the user will have previously configured a Source & Destination into a Connection. e.g. MySql -> CSV An invocation of trigger_sync will attempt to start a sync job for the specified connection_id representing the Connection in Airbyte. trigger_sync will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. Parameters: Name Type Description Default connection_id str Airbyte connection ID to trigger a sync for. required airbyte_server_host str Airbyte instance hostname where connection is configured. 'localhost' airbyte_server_port int Port where Airbyte instance is listening. '8000' airbyte_api_version str Version of Airbyte API to use to trigger connection sync. 'v1' poll_interval_s int How often to poll Airbyte for sync status. 15 status_updates bool Whether to log sync job status while polling. False timeout int The POST request timeout for the httpx.AsyncClient . 5 Raises: Type Description ValueError If connection_id is not a valid UUID. err . AirbyteSyncJobFailed If airbyte returns JOB_STATUS_FAILED . err . AirbyteConnectionInactiveException If a given connection is inactive. err . AirbyeConnectionDeprecatedException If a given connection is deprecated. Returns: Type Description dict Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( connection_id = \"your-connection-id-to-sync\" ) example_trigger_sync_flow () Source code in prefect_airbyte/connections.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 @task async def trigger_sync ( connection_id : str , airbyte_server_host : str = \"localhost\" , airbyte_server_port : int = \"8000\" , airbyte_api_version : str = \"v1\" , poll_interval_s : int = 15 , status_updates : bool = False , timeout : int = 5 , ) -> dict : \"\"\"Prefect Task for triggering an Airbyte connection sync. *It is assumed that the user will have previously configured a Source & Destination into a Connection.* e.g. MySql -> CSV An invocation of `trigger_sync` will attempt to start a sync job for the specified `connection_id` representing the Connection in Airbyte. `trigger_sync` will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. Args: connection_id: Airbyte connection ID to trigger a sync for. airbyte_server_host: Airbyte instance hostname where connection is configured. airbyte_server_port: Port where Airbyte instance is listening. airbyte_api_version: Version of Airbyte API to use to trigger connection sync. poll_interval_s: How often to poll Airbyte for sync status. status_updates: Whether to log sync job status while polling. timeout: The POST request `timeout` for the `httpx.AsyncClient`. Raises: ValueError: If `connection_id` is not a valid UUID. err.AirbyteSyncJobFailed: If airbyte returns `JOB_STATUS_FAILED`. err.AirbyteConnectionInactiveException: If a given connection is inactive. err.AirbyeConnectionDeprecatedException: If a given connection is deprecated. Returns: Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: ```python from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow(): # Run other tasks and subflows here trigger_sync( connection_id=\"your-connection-id-to-sync\" ) example_trigger_sync_flow() ``` \"\"\" logger = get_logger () try : uuid . UUID ( connection_id ) except ( TypeError , ValueError ): raise ValueError ( \"Parameter `connection_id` *must* be a valid UUID \\ i.e. 32 hex characters, including hyphens.\" ) # see https://airbyte-public-api-docs.s3.us-east-2.amazonaws.com # /rapidoc-api-docs.html#overview airbyte_base_url = ( f \"http:// { airbyte_server_host } :\" f \" { airbyte_server_port } /api/ { airbyte_api_version } \" ) airbyte = AirbyteClient ( logger , airbyte_base_url , timeout = timeout ) logger . info ( f \"Getting Airbyte Connection { connection_id } , poll interval \" f \" { poll_interval_s } seconds, airbyte_base_url { airbyte_base_url } \" ) connection_status = await airbyte . get_connection_status ( connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : # Trigger manual sync on the Connection ... job_id , job_created_at = await airbyte . trigger_manual_sync_connection ( connection_id ) job_status = JOB_STATUS_PENDING while job_status not in [ JOB_STATUS_FAILED , JOB_STATUS_SUCCEEDED ]: job_status , job_created_at , job_updated_at = await airbyte . get_job_status ( job_id ) # pending\u2503running\u2503incomplete\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : logger . info ( f \"Job { job_id } succeeded.\" ) elif job_status == JOB_STATUS_FAILED : logger . error ( f \"Job { job_id } failed.\" ) raise err . AirbyteSyncJobFailed ( f \"Job { job_id } failed.\" ) else : if status_updates : logger . info ( job_status ) # wait for next poll interval await sleep ( poll_interval_s ) return { \"connection_id\" : connection_id , \"status\" : connection_status , \"job_status\" : job_status , \"job_created_at\" : job_created_at , \"job_updated_at\" : job_updated_at , } elif connection_status == CONNECTION_STATUS_INACTIVE : logger . error ( f \"Connection: { connection_id } is inactive\" \" - you'll need to enable it in your Airbyte instance\" ) raise err . AirbyteConnectionInactiveException ( f \"Please enable the Connection { connection_id } in Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : logger . error ( f \"Connection { connection_id } is deprecated.\" ) raise err . AirbyeConnectionDeprecatedException ( f \"Connection { connection_id } is deprecated.\" )","title":"trigger_sync()"}]}