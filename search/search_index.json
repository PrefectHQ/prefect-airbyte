{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"prefect-airbyte","text":""},{"location":"#welcome","title":"Welcome!","text":"<p><code>prefect-airbyte</code> is a collection of prebuilt Prefect tasks and flows that can be used to quickly construct Prefect flows to interact with Airbyte.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#python-setup","title":"Python setup","text":"<p>Requires an installation of Python 3.7+</p> <p>We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv.</p> <p>These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation.</p>"},{"location":"#airbyte-setup","title":"Airbyte setup","text":"<p>See the airbyte documention on how to get your own instance.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>prefect-airbyte</code></p> <pre><code>pip install prefect-airbyte\n</code></pre> <p>A list of available blocks in <code>prefect-airbyte</code> and their setup instructions can be found here.</p>"},{"location":"#examples","title":"Examples","text":""},{"location":"#create-an-airbyteserver-block-and-save-it","title":"Create an <code>AirbyteServer</code> block and save it","text":"<pre><code>from prefect_airbyte.server import AirbyteServer\n\n# running airbyte locally at http://localhost:8000 with default auth\nlocal_airbyte_server = AirbyteServer()\n\n# running airbyte remotely at http://&lt;someIP&gt;:&lt;somePort&gt; as user `Marvin`\nremote_airbyte_server = AirbyteServer(\n    username=\"Marvin\",\n    password=\"DontPanic42\",\n    server_host=\"42.42.42.42\",\n    server_port=\"4242\"\n)\n\nlocal_airbyte_server.save(\"my-local-airbyte-server\")\n\nremote_airbyte_server.save(\"my-remote-airbyte-server\")\n</code></pre>"},{"location":"#trigger-a-defined-connection-sync","title":"Trigger a defined connection sync","text":"<pre><code>from prefect import flow\nfrom prefect_airbyte.server import AirbyteServer\nfrom prefect_airbyte.connections import AirbyteConnection\nfrom prefect_airbyte.flows import run_connection_sync\n\nserver = AirbyteServer(server_host=\"localhost\", server_port=8000)\n\nconnection = AirbyteConnection(\n    airbyte_server=server,\n    connection_id=\"e1b2078f-882a-4f50-9942-cfe34b2d825b\",\n    status_updates=True,\n)\n\n@flow\ndef airbyte_syncs():\n    # do some setup\n\n    sync_result = run_connection_sync(\n        airbyte_connection=connection,\n    )\n\n    # do some other things, like trigger DBT based on number of records synced\n    print(f'Number of Records Synced: {sync_result.records_synced}')\n</code></pre> <pre><code>\u276f python airbyte_syncs.py\n03:46:03 | prefect.engine - Created flow run 'thick-seahorse' for flow 'example_trigger_sync_flow'\n03:46:03 | Flow run 'thick-seahorse' - Using task runner 'ConcurrentTaskRunner'\n03:46:03 | Flow run 'thick-seahorse' - Created task run 'trigger_sync-35f0e9c2-0' for task 'trigger_sync'\n03:46:03 | prefect - trigger airbyte connection: e1b2078f-882a-4f50-9942-cfe34b2d825b, poll interval 3 seconds\n03:46:03 | prefect - pending\n03:46:06 | prefect - running\n03:46:09 | prefect - running\n03:46:12 | prefect - running\n03:46:16 | prefect - running\n03:46:19 | prefect - running\n03:46:22 | prefect - Job 26 succeeded.\n03:46:22 | Task run 'trigger_sync-35f0e9c2-0' - Finished in state Completed(None)\n03:46:22 | Flow run 'thick-seahorse' - Finished in state Completed('All states completed.')\n</code></pre>"},{"location":"#export-an-airbyte-instances-configuration","title":"Export an Airbyte instance's configuration","text":"<p>NOTE: The API endpoint corresponding to this task is no longer supported by open-source Airbyte versions as of v0.40.7. Check out the Octavia CLI docs for more info.</p> <pre><code>import gzip\n\nfrom prefect import flow, task\nfrom prefect_airbyte.configuration import export_configuration\nfrom prefect_airbyte.server import AirbyteServer\n\n@task\ndef zip_and_write_somewhere(\n      airbyte_config: bytearray,\n      somewhere: str,\n):\n    with gzip.open(somewhere, 'wb') as f:\n        f.write(airbyte_config)\n\n@flow\ndef example_export_configuration_flow(filepath: str):\n\n    # Run other tasks and subflows here\n\n    airbyte_config = export_configuration(\n        airbyte_server=AirbyteServer.load(\"my-airbyte-server-block\")\n    )\n\n    zip_and_write_somewhere(\n        somewhere=filepath,\n        airbyte_config=airbyte_config\n    )\n\nif __name__ == \"__main__\":\n    example_export_configuration_flow('*://**/my_destination.gz')\n</code></pre>"},{"location":"#use-with_options-to-customize-options-on-any-existing-task-or-flow","title":"Use <code>with_options</code> to customize options on any existing task or flow","text":"<pre><code>from prefect import flow\nfrom prefect_airbyte.connections import AirbyteConnection\nfrom prefect_airbyte.flows import run_connection_sync\n\ncustom_run_connection_sync = run_connection_sync.with_options(\n    name=\"Custom Airbyte Sync Flow\",\n    retries=2,\n    retry_delay_seconds=10,\n)\n\n @flow\n def some_airbyte_flow():\n    custom_run_connection_sync(\n        airbyte_connection=AirbyteConnection.load(\"my-airbyte-connection-block\")\n    )\n\n some_airbyte_flow()\n</code></pre> <p>For more tips on how to use tasks and flows in a Collection, check out Using Collections!</p>"},{"location":"#blocks-catalog","title":"Blocks Catalog","text":"<p>Below is a list of Blocks available for registration in <code>prefect-airbyte</code>.</p> <p>To register blocks in this module to view and edit them on Prefect Cloud: <pre><code>prefect block register -m prefect_airbyte\n</code></pre> Note, to use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p>"},{"location":"#server-module","title":"Server Module","text":"<p>AirbyteServer</p> <p>To load the AirbyteServer: <pre><code>from prefect import flow\nfrom prefect_airbyte.server import AirbyteServer\n\n@flow\ndef my_flow():\n    my_block = AirbyteServer.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre></p>"},{"location":"#connections-module","title":"Connections Module","text":"<p>AirbyteConnection</p> <p>To load the AirbyteConnection: <pre><code>from prefect import flow\nfrom prefect_airbyte.connections import AirbyteConnection\n\n@flow\ndef my_flow():\n    my_block = AirbyteConnection.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre></p>"},{"location":"#resources","title":"Resources","text":"<p>If you encounter and bugs while using <code>prefect-airbyte</code>, feel free to open an issue in the prefect-airbyte repository.</p> <p>If you have any questions or issues while using <code>prefect-airbyte</code>, you can find help in either the Prefect Discourse forum or the Prefect Slack community</p> <p>Feel free to star or watch <code>prefect-airbyte</code> for updates too!</p>"},{"location":"#contribute","title":"Contribute","text":"<p>If you'd like to help contribute to fix an issue or add a feature to <code>prefect-airbyte</code>, please propose changes through a pull request from a fork of the repository.</p>"},{"location":"#contribution-steps","title":"Contribution Steps:","text":"<ol> <li>Fork the repository</li> <li>Clone the forked repository</li> <li>Install the repository and its dependencies: <pre><code>pip install -e \".[dev]\"\n</code></pre></li> <li>Make desired changes.</li> <li>Add tests.</li> <li>Insert an entry to CHANGELOG.md</li> <li>Install <code>pre-commit</code> to perform quality checks prior to commit: <code>pre-commit install</code></li> <li><code>git commit</code>, <code>git push</code>, and create a pull request.</li> </ol>"},{"location":"client/","title":"Client","text":""},{"location":"client/#prefect_airbyte.client","title":"<code>prefect_airbyte.client</code>","text":"<p>Client for interacting with Airbyte instance</p>"},{"location":"client/#prefect_airbyte.client-classes","title":"Classes","text":""},{"location":"client/#prefect_airbyte.client.AirbyteClient","title":"<code>AirbyteClient</code>","text":"<p>Client class used to call API endpoints on an Airbyte server.</p> <p>This client currently supports username/password authentication as set in <code>auth</code>.</p> <p>For more info, see the Airbyte docs.</p> <p>Attributes:</p> Name Type Description <code>airbyte_base_url</code> <code>str</code> <p>Base API endpoint URL for Airbyte.</p> <code>auth</code> <p>Username and password for Airbyte API.</p> <code>logger</code> <p>A logger instance used by the client to log messages related to API calls.</p> <code>timeout</code> <p>The number of seconds to wait before an API call times out.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>class AirbyteClient:\n\"\"\"\n    Client class used to call API endpoints on an Airbyte server.\n\n    This client currently supports username/password authentication as set in `auth`.\n\n    For more info, see the [Airbyte docs](https://docs.airbyte.io/api-documentation).\n\n    Attributes:\n        airbyte_base_url str: Base API endpoint URL for Airbyte.\n        auth: Username and password for Airbyte API.\n        logger: A logger instance used by the client to log messages related to\n            API calls.\n        timeout: The number of seconds to wait before an API call times out.\n    \"\"\"\n\n    def __init__(\n        self,\n        logger: logging.Logger,\n        airbyte_base_url: str = \"http://localhost:8000/api/v1\",\n        auth: Tuple[str, str] = (\"airbyte\", \"password\"),\n        timeout: int = 5,\n    ):\n        self._closed = False\n        self._started = False\n\n        self.airbyte_base_url = airbyte_base_url\n        self.auth = auth\n        self.logger = logger\n        self.timeout = timeout\n        self._client = httpx.AsyncClient(\n            base_url=self.airbyte_base_url, auth=self.auth, timeout=self.timeout\n        )\n\n    async def check_health_status(self, client: httpx.AsyncClient) -&gt; bool:\n\"\"\"\n        Checks the health status of an Airbyte instance.\n\n        Args:\n            client: `httpx.AsyncClient` used to interact with the Airbyte API.\n\n        Returns:\n            True if the server is healthy. False otherwise.\n        \"\"\"\n        get_connection_url = self.airbyte_base_url + \"/health/\"\n        try:\n            response = await client.get(get_connection_url)\n            response.raise_for_status()\n\n            self.logger.debug(\"Health check response: %s\", response.json())\n            key = \"available\" if \"available\" in response.json() else \"db\"\n            health_status = response.json()[key]\n            if not health_status:\n                raise err.AirbyteServerNotHealthyException(\n                    f\"Airbyte Server health status: {health_status}\"\n                )\n            return True\n        except httpx.HTTPStatusError as e:\n            raise err.AirbyteServerNotHealthyException() from e\n\n    async def export_configuration(\n        self,\n    ) -&gt; bytes:\n\"\"\"\n        Triggers an export of Airbyte configuration.\n\n        **Note**: As of Airbyte v0.40.7-alpha, this endpoint no longer exists.\n\n        Returns:\n            Gzipped Airbyte configuration data.\n        \"\"\"\n        warn(\n            \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \"\n            \"exporting configurations. See the Octavia CLI docs for more info.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        get_connection_url = self.airbyte_base_url + \"/deployment/export/\"\n\n        try:\n            response = await self._client.post(get_connection_url)\n            response.raise_for_status()\n\n            self.logger.debug(\"Export configuration response: %s\", response)\n\n            export_config = response.content\n            return export_config\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 404:\n                self.logger.error(\n                    \"If you are using Airbyte v0.40.7-alpha, there is no longer \"\n                    \"an API endpoint for exporting configurations.\"\n                )\n                raise err.AirbyteExportConfigurationFailed() from e\n\n    async def get_connection_status(self, connection_id: str) -&gt; str:\n\"\"\"\n        Gets the status of a defined Airbyte connection.\n\n        Args:\n            connection_id: ID of an existing Airbyte connection.\n\n        Returns:\n            The status of the defined Airbyte connection.\n        \"\"\"\n        get_connection_url = self.airbyte_base_url + \"/connections/get/\"\n\n        try:\n            response = await self._client.post(\n                get_connection_url, json={\"connectionId\": connection_id}\n            )\n\n            response.raise_for_status()\n\n            connection_status = response.json()[\"status\"]\n            return connection_status\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 404:\n                raise err.ConnectionNotFoundException() from e\n            else:\n                raise err.AirbyteServerNotHealthyException() from e\n\n    async def trigger_manual_sync_connection(\n        self, connection_id: str\n    ) -&gt; Tuple[str, str]:\n\"\"\"\n        Triggers a manual sync of the connection.\n\n        Args:\n            connection_id: ID of connection to sync.\n\n        Returns:\n            job_id: ID of the job that was triggered.\n            created_at: Datetime string of when the job was created.\n\n        \"\"\"\n        get_connection_url = self.airbyte_base_url + \"/connections/sync/\"\n\n        try:\n            response = await self._client.post(\n                get_connection_url, json={\"connectionId\": connection_id}\n            )\n            response.raise_for_status()\n            job = response.json()[\"job\"]\n            job_id = job[\"id\"]\n            job_created_at = job[\"createdAt\"]\n            return job_id, job_created_at\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 404:\n                raise err.ConnectionNotFoundException(\n                    f\"Connection {connection_id} not found, please double \"\n                    f\"check the connection_id.\"\n                ) from e\n\n            raise err.AirbyteServerNotHealthyException() from e\n\n    async def get_job_status(self, job_id: str) -&gt; Tuple[str, int, int]:\n\"\"\"\n        Gets the status of an Airbyte connection sync job.\n\n        **Note**: Deprecated in favor of `AirbyteClient.get_job_info`.\n\n        Args:\n            job_id: ID of the Airbyte job to check.\n\n        Returns:\n            job_status: The current status of the job.\n            job_created_at: Datetime string of when the job was created.\n            job_updated_at: Datetime string of the when the job was last updated.\n        \"\"\"\n        warn(\n            \"`AirbyteClient.get_job_status` is deprecated and will be removed in \"\n            \"a future release. If you are using this client method directly, please \"\n            \"use the `AirbyteClient.get_job_info` method instead. If you are\"\n            \"seeing this warning while using the `trigger_sync` task, please \"\n            \"define an `AirbyteConnection` and use `run_connection_sync` instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        get_connection_url = self.airbyte_base_url + \"/jobs/get/\"\n        try:\n            response = await self._client.post(get_connection_url, json={\"id\": job_id})\n            response.raise_for_status()\n\n            job = response.json()[\"job\"]\n            job_status = job[\"status\"]\n            job_created_at = job[\"createdAt\"]\n            job_updated_at = job[\"updatedAt\"]\n            return job_status, job_created_at, job_updated_at\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 404:\n                raise err.JobNotFoundException(f\"Job {job_id} not found.\") from e\n            raise err.AirbyteServerNotHealthyException() from e\n\n    async def get_job_info(self, job_id: str) -&gt; Dict[str, Any]:\n\"\"\"\n        Gets the full API response for a given Airbyte Job ID.\n\n        Args:\n            job_id: The ID of the Airbyte job to retrieve information on.\n\n        Returns:\n            Dict of the full API response for the given job ID.\n        \"\"\"\n        get_connection_url = self.airbyte_base_url + \"/jobs/get/\"\n        try:\n            response = await self._client.post(get_connection_url, json={\"id\": job_id})\n            response.raise_for_status()\n\n            return response.json()\n\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 404:\n                raise err.JobNotFoundException(f\"Job {job_id} not found.\") from e\n            raise err.AirbyteServerNotHealthyException() from e\n\n    async def create_client(self) -&gt; httpx.AsyncClient:\n\"\"\"Convencience method to create a new httpx.AsyncClient.\n\n        To be removed in favor of using the entire `AirbyteClient` class\n        as a context manager.\n        \"\"\"\n        warn(\n            \"Use of this method will be removed in a future release - \"\n            \"please use the `AirbyteClient` class as a context manager.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self._client\n\n    async def __aenter__(self):\n\"\"\"Context manager entry point.\"\"\"\n        if self._closed:\n            raise RuntimeError(\n                \"The client cannot be started again after it has been closed.\"\n            )\n        if self._started:\n            raise RuntimeError(\"The client cannot be started more than once.\")\n\n        self._started = True\n\n        await self.check_health_status(self._client)\n\n        return self\n\n    async def __aexit__(self, *exc):\n\"\"\"Context manager exit point.\"\"\"\n\n        self._closed = True\n        await self._client.__aexit__()\n</code></pre>"},{"location":"client/#prefect_airbyte.client.AirbyteClient-functions","title":"Functions","text":""},{"location":"client/#prefect_airbyte.client.AirbyteClient.__aenter__","title":"<code>__aenter__</code>  <code>async</code>","text":"<p>Context manager entry point.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>async def __aenter__(self):\n\"\"\"Context manager entry point.\"\"\"\n    if self._closed:\n        raise RuntimeError(\n            \"The client cannot be started again after it has been closed.\"\n        )\n    if self._started:\n        raise RuntimeError(\"The client cannot be started more than once.\")\n\n    self._started = True\n\n    await self.check_health_status(self._client)\n\n    return self\n</code></pre>"},{"location":"client/#prefect_airbyte.client.AirbyteClient.__aexit__","title":"<code>__aexit__</code>  <code>async</code>","text":"<p>Context manager exit point.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>async def __aexit__(self, *exc):\n\"\"\"Context manager exit point.\"\"\"\n\n    self._closed = True\n    await self._client.__aexit__()\n</code></pre>"},{"location":"client/#prefect_airbyte.client.AirbyteClient.check_health_status","title":"<code>check_health_status</code>  <code>async</code>","text":"<p>Checks the health status of an Airbyte instance.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>httpx.AsyncClient</code> <p><code>httpx.AsyncClient</code> used to interact with the Airbyte API.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the server is healthy. False otherwise.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>async def check_health_status(self, client: httpx.AsyncClient) -&gt; bool:\n\"\"\"\n    Checks the health status of an Airbyte instance.\n\n    Args:\n        client: `httpx.AsyncClient` used to interact with the Airbyte API.\n\n    Returns:\n        True if the server is healthy. False otherwise.\n    \"\"\"\n    get_connection_url = self.airbyte_base_url + \"/health/\"\n    try:\n        response = await client.get(get_connection_url)\n        response.raise_for_status()\n\n        self.logger.debug(\"Health check response: %s\", response.json())\n        key = \"available\" if \"available\" in response.json() else \"db\"\n        health_status = response.json()[key]\n        if not health_status:\n            raise err.AirbyteServerNotHealthyException(\n                f\"Airbyte Server health status: {health_status}\"\n            )\n        return True\n    except httpx.HTTPStatusError as e:\n        raise err.AirbyteServerNotHealthyException() from e\n</code></pre>"},{"location":"client/#prefect_airbyte.client.AirbyteClient.create_client","title":"<code>create_client</code>  <code>async</code>","text":"<p>Convencience method to create a new httpx.AsyncClient.</p> <p>To be removed in favor of using the entire <code>AirbyteClient</code> class as a context manager.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>async def create_client(self) -&gt; httpx.AsyncClient:\n\"\"\"Convencience method to create a new httpx.AsyncClient.\n\n    To be removed in favor of using the entire `AirbyteClient` class\n    as a context manager.\n    \"\"\"\n    warn(\n        \"Use of this method will be removed in a future release - \"\n        \"please use the `AirbyteClient` class as a context manager.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return self._client\n</code></pre>"},{"location":"client/#prefect_airbyte.client.AirbyteClient.export_configuration","title":"<code>export_configuration</code>  <code>async</code>","text":"<p>Triggers an export of Airbyte configuration.</p> <p>Note: As of Airbyte v0.40.7-alpha, this endpoint no longer exists.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Gzipped Airbyte configuration data.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>async def export_configuration(\n    self,\n) -&gt; bytes:\n\"\"\"\n    Triggers an export of Airbyte configuration.\n\n    **Note**: As of Airbyte v0.40.7-alpha, this endpoint no longer exists.\n\n    Returns:\n        Gzipped Airbyte configuration data.\n    \"\"\"\n    warn(\n        \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \"\n        \"exporting configurations. See the Octavia CLI docs for more info.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    get_connection_url = self.airbyte_base_url + \"/deployment/export/\"\n\n    try:\n        response = await self._client.post(get_connection_url)\n        response.raise_for_status()\n\n        self.logger.debug(\"Export configuration response: %s\", response)\n\n        export_config = response.content\n        return export_config\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            self.logger.error(\n                \"If you are using Airbyte v0.40.7-alpha, there is no longer \"\n                \"an API endpoint for exporting configurations.\"\n            )\n            raise err.AirbyteExportConfigurationFailed() from e\n</code></pre>"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_connection_status","title":"<code>get_connection_status</code>  <code>async</code>","text":"<p>Gets the status of a defined Airbyte connection.</p> <p>Parameters:</p> Name Type Description Default <code>connection_id</code> <code>str</code> <p>ID of an existing Airbyte connection.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The status of the defined Airbyte connection.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>async def get_connection_status(self, connection_id: str) -&gt; str:\n\"\"\"\n    Gets the status of a defined Airbyte connection.\n\n    Args:\n        connection_id: ID of an existing Airbyte connection.\n\n    Returns:\n        The status of the defined Airbyte connection.\n    \"\"\"\n    get_connection_url = self.airbyte_base_url + \"/connections/get/\"\n\n    try:\n        response = await self._client.post(\n            get_connection_url, json={\"connectionId\": connection_id}\n        )\n\n        response.raise_for_status()\n\n        connection_status = response.json()[\"status\"]\n        return connection_status\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise err.ConnectionNotFoundException() from e\n        else:\n            raise err.AirbyteServerNotHealthyException() from e\n</code></pre>"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_job_info","title":"<code>get_job_info</code>  <code>async</code>","text":"<p>Gets the full API response for a given Airbyte Job ID.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>The ID of the Airbyte job to retrieve information on.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict of the full API response for the given job ID.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>async def get_job_info(self, job_id: str) -&gt; Dict[str, Any]:\n\"\"\"\n    Gets the full API response for a given Airbyte Job ID.\n\n    Args:\n        job_id: The ID of the Airbyte job to retrieve information on.\n\n    Returns:\n        Dict of the full API response for the given job ID.\n    \"\"\"\n    get_connection_url = self.airbyte_base_url + \"/jobs/get/\"\n    try:\n        response = await self._client.post(get_connection_url, json={\"id\": job_id})\n        response.raise_for_status()\n\n        return response.json()\n\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise err.JobNotFoundException(f\"Job {job_id} not found.\") from e\n        raise err.AirbyteServerNotHealthyException() from e\n</code></pre>"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_job_status","title":"<code>get_job_status</code>  <code>async</code>","text":"<p>Gets the status of an Airbyte connection sync job.</p> <p>Note: Deprecated in favor of <code>AirbyteClient.get_job_info</code>.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>ID of the Airbyte job to check.</p> required <p>Returns:</p> Name Type Description <code>job_status</code> <code>str</code> <p>The current status of the job.</p> <code>job_created_at</code> <code>int</code> <p>Datetime string of when the job was created.</p> <code>job_updated_at</code> <code>int</code> <p>Datetime string of the when the job was last updated.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>async def get_job_status(self, job_id: str) -&gt; Tuple[str, int, int]:\n\"\"\"\n    Gets the status of an Airbyte connection sync job.\n\n    **Note**: Deprecated in favor of `AirbyteClient.get_job_info`.\n\n    Args:\n        job_id: ID of the Airbyte job to check.\n\n    Returns:\n        job_status: The current status of the job.\n        job_created_at: Datetime string of when the job was created.\n        job_updated_at: Datetime string of the when the job was last updated.\n    \"\"\"\n    warn(\n        \"`AirbyteClient.get_job_status` is deprecated and will be removed in \"\n        \"a future release. If you are using this client method directly, please \"\n        \"use the `AirbyteClient.get_job_info` method instead. If you are\"\n        \"seeing this warning while using the `trigger_sync` task, please \"\n        \"define an `AirbyteConnection` and use `run_connection_sync` instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    get_connection_url = self.airbyte_base_url + \"/jobs/get/\"\n    try:\n        response = await self._client.post(get_connection_url, json={\"id\": job_id})\n        response.raise_for_status()\n\n        job = response.json()[\"job\"]\n        job_status = job[\"status\"]\n        job_created_at = job[\"createdAt\"]\n        job_updated_at = job[\"updatedAt\"]\n        return job_status, job_created_at, job_updated_at\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise err.JobNotFoundException(f\"Job {job_id} not found.\") from e\n        raise err.AirbyteServerNotHealthyException() from e\n</code></pre>"},{"location":"client/#prefect_airbyte.client.AirbyteClient.trigger_manual_sync_connection","title":"<code>trigger_manual_sync_connection</code>  <code>async</code>","text":"<p>Triggers a manual sync of the connection.</p> <p>Parameters:</p> Name Type Description Default <code>connection_id</code> <code>str</code> <p>ID of connection to sync.</p> required <p>Returns:</p> Name Type Description <code>job_id</code> <code>str</code> <p>ID of the job that was triggered.</p> <code>created_at</code> <code>str</code> <p>Datetime string of when the job was created.</p> Source code in <code>prefect_airbyte/client.py</code> <pre><code>async def trigger_manual_sync_connection(\n    self, connection_id: str\n) -&gt; Tuple[str, str]:\n\"\"\"\n    Triggers a manual sync of the connection.\n\n    Args:\n        connection_id: ID of connection to sync.\n\n    Returns:\n        job_id: ID of the job that was triggered.\n        created_at: Datetime string of when the job was created.\n\n    \"\"\"\n    get_connection_url = self.airbyte_base_url + \"/connections/sync/\"\n\n    try:\n        response = await self._client.post(\n            get_connection_url, json={\"connectionId\": connection_id}\n        )\n        response.raise_for_status()\n        job = response.json()[\"job\"]\n        job_id = job[\"id\"]\n        job_created_at = job[\"createdAt\"]\n        return job_id, job_created_at\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise err.ConnectionNotFoundException(\n                f\"Connection {connection_id} not found, please double \"\n                f\"check the connection_id.\"\n            ) from e\n\n        raise err.AirbyteServerNotHealthyException() from e\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#prefect_airbyte.configuration","title":"<code>prefect_airbyte.configuration</code>","text":"<p>Tasks for updating and fetching Airbyte configurations</p>"},{"location":"configuration/#prefect_airbyte.configuration-classes","title":"Classes","text":""},{"location":"configuration/#prefect_airbyte.configuration-functions","title":"Functions","text":""},{"location":"configuration/#prefect_airbyte.configuration.export_configuration","title":"<code>export_configuration</code>  <code>async</code>","text":"<p>Prefect Task that exports an Airbyte configuration via <code>{airbyte_server_host}/api/v1/deployment/export</code>.</p> <p>As of <code>prefect-airbyte==0.1.3</code>, the kwargs <code>airbyte_server_host</code> and <code>airbyte_server_port</code> can be replaced by passing an <code>airbyte_server</code> block instance to generate the <code>AirbyteClient</code>. Using the <code>airbyte_server</code> block is preferred, but the individual kwargs remain for backwards compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>airbyte_server</code> <code>Optional[AirbyteServer]</code> <p>An <code>AirbyteServer</code> block for generating an <code>AirbyteClient</code>.</p> <code>None</code> <code>airbyte_server_host</code> <code>Optional[str]</code> <p>Airbyte server host to connect to.</p> <code>None</code> <code>airbyte_server_port</code> <code>Optional[int]</code> <p>Airbyte server port to connect to.</p> <code>None</code> <code>airbyte_api_version</code> <code>Optional[str]</code> <p>Airbyte API version to use.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds on the <code>httpx.AsyncClient</code>.</p> <code>5</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes containing Airbyte configuration</p> <p>Examples:</p> <p>Flow that writes the Airbyte configuration as a gzip to a filepath:</p> <pre><code>import gzip\n\nfrom prefect import flow, task\nfrom prefect_airbyte.configuration import export_configuration\nfrom prefect_airbyte.server import AirbyteServer\n\n@task\ndef zip_and_write_somewhere(\n    airbyte_configuration: bytes\n    somewhere: str = 'my_destination.gz','\n):\n    with gzip.open('my_destination.gz', 'wb') as f:\n            f.write(airbyte_configuration)\n\n@flow\ndef example_export_configuration_flow():\n\n    # Run other tasks and subflows here\n\n    airbyte_config = export_configuration(\n        airbyte_server=AirbyteServer.load(\"oss-airbyte\")\n    )\n\n    zip_and_write_somewhere(airbyte_config=airbyte_config)\n\nexample_trigger_sync_flow()\n</code></pre> Source code in <code>prefect_airbyte/configuration.py</code> <pre><code>@task\nasync def export_configuration(\n    airbyte_server: Optional[AirbyteServer] = None,\n    airbyte_server_host: Optional[str] = None,\n    airbyte_server_port: Optional[int] = None,\n    airbyte_api_version: Optional[str] = None,\n    timeout: int = 5,\n) -&gt; bytes:\n\n\"\"\"\n    Prefect Task that exports an Airbyte configuration via\n    `{airbyte_server_host}/api/v1/deployment/export`.\n\n    As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and\n    `airbyte_server_port` can be replaced by passing an `airbyte_server` block\n    instance to generate the `AirbyteClient`. Using the `airbyte_server` block is\n    preferred, but the individual kwargs remain for backwards compatibility.\n\n    Args:\n        airbyte_server: An `AirbyteServer` block for generating an `AirbyteClient`.\n        airbyte_server_host: Airbyte server host to connect to.\n        airbyte_server_port: Airbyte server port to connect to.\n        airbyte_api_version: Airbyte API version to use.\n        timeout: Timeout in seconds on the `httpx.AsyncClient`.\n\n    Returns:\n        Bytes containing Airbyte configuration\n\n    Examples:\n\n        Flow that writes the Airbyte configuration as a gzip to a filepath:\n\n        ```python\n        import gzip\n\n        from prefect import flow, task\n        from prefect_airbyte.configuration import export_configuration\n        from prefect_airbyte.server import AirbyteServer\n\n        @task\n        def zip_and_write_somewhere(\n            airbyte_configuration: bytes\n            somewhere: str = 'my_destination.gz','\n        ):\n            with gzip.open('my_destination.gz', 'wb') as f:\n                    f.write(airbyte_configuration)\n\n        @flow\n        def example_export_configuration_flow():\n\n            # Run other tasks and subflows here\n\n            airbyte_config = export_configuration(\n                airbyte_server=AirbyteServer.load(\"oss-airbyte\")\n            )\n\n            zip_and_write_somewhere(airbyte_config=airbyte_config)\n\n        example_trigger_sync_flow()\n        ```\n    \"\"\"\n    logger = get_run_logger()\n\n    if not airbyte_server:\n        warn(\n            \"The use of `airbyte_server_host`, `airbyte_server_port`, and \"\n            \"`airbyte_api_version` is deprecated and will be removed in a \"\n            \"future release. Please pass an `airbyte_server` block to this \"\n            \"task instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        if any([airbyte_server_host, airbyte_server_port, airbyte_api_version]):\n            airbyte_server = AirbyteServer(\n                server_host=airbyte_server_host or \"localhost\",\n                server_port=airbyte_server_port or 8000,\n                api_version=airbyte_api_version or \"v1\",\n            )\n        else:\n            airbyte_server = AirbyteServer()\n    else:\n        if any([airbyte_server_host, airbyte_server_port, airbyte_api_version]):\n            logger.info(\n                \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \"\n                \"and `airbyte_server_port` because `airbyte_server` block \"\n                \" was passed. Using API URL from `airbyte_server` block: \"\n                f\"{airbyte_server.base_url!r}.\"\n            )\n\n    async with airbyte_server.get_client(\n        logger=logger, timeout=timeout\n    ) as airbyte_client:\n\n        logger.info(\"Initiating export of Airbyte configuration\")\n\n        return await airbyte_client.export_configuration()\n</code></pre>"},{"location":"connections/","title":"Connections","text":""},{"location":"connections/#prefect_airbyte.connections","title":"<code>prefect_airbyte.connections</code>","text":"<p>Tasks for connecting to Airbyte and triggering connection syncs</p>"},{"location":"connections/#prefect_airbyte.connections-classes","title":"Classes","text":""},{"location":"connections/#prefect_airbyte.connections.AirbyteConnection","title":"<code>AirbyteConnection</code>","text":"<p>         Bases: <code>JobBlock</code></p> <p>A block representing an existing Airbyte connection.</p> <p>Attributes:</p> Name Type Description <code>airbyte_server</code> <code>AirbyteServer</code> <p><code>AirbyteServer</code> block representing the Airbyte instance where the Airbyte connection is defined.</p> <code>connection_id</code> <code>uuid.UUID</code> <p>UUID of the Airbyte Connection to trigger.</p> <code>poll_interval_s</code> <code>int</code> <p>Time in seconds between status checks of the Airbyte sync job.</p> <code>status_updates</code> <code>bool</code> <p>Whether to log job status on each poll of the Airbyte sync job.</p> <code>timeout</code> <code>int</code> <p>Timeout in seconds for requests made by <code>httpx.AsyncClient</code>.</p> <p>Examples:</p> <p>Load an existing <code>AirbyteConnection</code> block: <pre><code>from prefect_airbyte import AirbyteConnection\n\nairbyte_connection = AirbyteConnection.load(\"BLOCK_NAME\")\n</code></pre></p> <p>Run an Airbyte connection sync as a flow: <pre><code>from prefect import flow\nfrom prefect_airbyte import AirbyteConnection\nfrom prefect_airbyte.flows import run_connection_sync # this is a flow\n\nairbyte_connection = AirbyteConnection.load(\"BLOCK_NAME\")\n\n@flow\ndef airbyte_orchestrator():\n    run_connection_sync(airbyte_connection) # now it's a subflow\n</code></pre></p> Source code in <code>prefect_airbyte/connections.py</code> <pre><code>class AirbyteConnection(JobBlock):\n\"\"\"A block representing an existing Airbyte connection.\n\n    Attributes:\n        airbyte_server: `AirbyteServer` block representing the Airbyte instance\n            where the Airbyte connection is defined.\n        connection_id: UUID of the Airbyte Connection to trigger.\n        poll_interval_s: Time in seconds between status checks of the Airbyte sync job.\n        status_updates: Whether to log job status on each poll of the Airbyte sync job.\n        timeout: Timeout in seconds for requests made by `httpx.AsyncClient`.\n\n    Examples:\n        Load an existing `AirbyteConnection` block:\n        ```python\n        from prefect_airbyte import AirbyteConnection\n\n        airbyte_connection = AirbyteConnection.load(\"BLOCK_NAME\")\n        ```\n\n        Run an Airbyte connection sync as a flow:\n        ```python\n        from prefect import flow\n        from prefect_airbyte import AirbyteConnection\n        from prefect_airbyte.flows import run_connection_sync # this is a flow\n\n        airbyte_connection = AirbyteConnection.load(\"BLOCK_NAME\")\n\n        @flow\n        def airbyte_orchestrator():\n            run_connection_sync(airbyte_connection) # now it's a subflow\n        ```\n    \"\"\"\n\n    _block_type_name = \"Airbyte Connection\"\n    _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/6gm7wsC7ANnKYQsm7oiSYz/aac1ad5e054d35d9e24af8d6ed3aed5f/59758427?h=250\"  # noqa: E501\n    _documentation_url = \"https://prefecthq.github.io/prefect-airbyte/connections/#prefect_airbyte.connections.AirbyteConnection\"  # noqa\n\n    airbyte_server: AirbyteServer = Field(\n        default=...,\n        description=(\n            \"AirbyteServer block representing the Airbyte instance \"\n            \"where the Airbyte connection is defined.\"\n        ),\n    )\n\n    connection_id: uuid.UUID = Field(\n        default=...,\n        description=\"UUID of the Airbyte Connection to trigger.\",\n    )\n\n    poll_interval_s: int = Field(\n        default=15,\n        description=\"Time in seconds between status checks of the Airbyte sync job.\",\n    )\n\n    status_updates: bool = Field(\n        default=False,\n        description=\"Whether to log job status on each poll of the Airbyte sync job.\",\n    )\n\n    timeout: int = Field(\n        default=5,\n        description=\"Timeout in seconds for requests made by httpx.AsyncClient.\",\n    )\n\n    @sync_compatible\n    async def trigger(self) -&gt; AirbyteSync:\n\"\"\"Trigger a sync of the defined Airbyte connection.\n\n        Returns:\n            An `AirbyteSync` `JobRun` object representing the active sync job.\n\n        Raises:\n            AirbyteConnectionInactiveException: If the connection is inactive.\n            AirbyteConnectionDeprecatedException: If the connection is deprecated.\n        \"\"\"\n        str_connection_id = str(self.connection_id)\n\n        async with self.airbyte_server.get_client(\n            logger=self.logger, timeout=self.timeout\n        ) as airbyte_client:\n\n            self.logger.info(\n                f\"Triggering Airbyte Connection {self.connection_id}, \"\n                f\"in workspace at {self.airbyte_server.base_url!r}\"\n            )\n\n            connection_status = await airbyte_client.get_connection_status(\n                str_connection_id\n            )\n\n            if connection_status == CONNECTION_STATUS_ACTIVE:\n                (job_id, _,) = await airbyte_client.trigger_manual_sync_connection(\n                    str_connection_id\n                )\n\n                return AirbyteSync(\n                    airbyte_connection=self,\n                    job_id=job_id,\n                )\n\n            elif connection_status == CONNECTION_STATUS_INACTIVE:\n                raise err.AirbyteConnectionInactiveException(\n                    f\"Connection: {self.connection_id!r} is inactive\"\n                    f\"Please enable the connection {self.connection_id!r} \"\n                    \"in your Airbyte instance.\"\n                )\n            elif connection_status == CONNECTION_STATUS_DEPRECATED:\n                raise err.AirbyeConnectionDeprecatedException(\n                    f\"Connection {self.connection_id!r} is deprecated.\"\n                )\n</code></pre>"},{"location":"connections/#prefect_airbyte.connections.AirbyteConnection-functions","title":"Functions","text":""},{"location":"connections/#prefect_airbyte.connections.AirbyteConnection.trigger","title":"<code>trigger</code>  <code>async</code>","text":"<p>Trigger a sync of the defined Airbyte connection.</p> <p>Returns:</p> Type Description <code>AirbyteSync</code> <p>An <code>AirbyteSync</code> <code>JobRun</code> object representing the active sync job.</p> <p>Raises:</p> Type Description <code>AirbyteConnectionInactiveException</code> <p>If the connection is inactive.</p> <code>AirbyteConnectionDeprecatedException</code> <p>If the connection is deprecated.</p> Source code in <code>prefect_airbyte/connections.py</code> <pre><code>@sync_compatible\nasync def trigger(self) -&gt; AirbyteSync:\n\"\"\"Trigger a sync of the defined Airbyte connection.\n\n    Returns:\n        An `AirbyteSync` `JobRun` object representing the active sync job.\n\n    Raises:\n        AirbyteConnectionInactiveException: If the connection is inactive.\n        AirbyteConnectionDeprecatedException: If the connection is deprecated.\n    \"\"\"\n    str_connection_id = str(self.connection_id)\n\n    async with self.airbyte_server.get_client(\n        logger=self.logger, timeout=self.timeout\n    ) as airbyte_client:\n\n        self.logger.info(\n            f\"Triggering Airbyte Connection {self.connection_id}, \"\n            f\"in workspace at {self.airbyte_server.base_url!r}\"\n        )\n\n        connection_status = await airbyte_client.get_connection_status(\n            str_connection_id\n        )\n\n        if connection_status == CONNECTION_STATUS_ACTIVE:\n            (job_id, _,) = await airbyte_client.trigger_manual_sync_connection(\n                str_connection_id\n            )\n\n            return AirbyteSync(\n                airbyte_connection=self,\n                job_id=job_id,\n            )\n\n        elif connection_status == CONNECTION_STATUS_INACTIVE:\n            raise err.AirbyteConnectionInactiveException(\n                f\"Connection: {self.connection_id!r} is inactive\"\n                f\"Please enable the connection {self.connection_id!r} \"\n                \"in your Airbyte instance.\"\n            )\n        elif connection_status == CONNECTION_STATUS_DEPRECATED:\n            raise err.AirbyeConnectionDeprecatedException(\n                f\"Connection {self.connection_id!r} is deprecated.\"\n            )\n</code></pre>"},{"location":"connections/#prefect_airbyte.connections.AirbyteSync","title":"<code>AirbyteSync</code>","text":"<p>         Bases: <code>JobRun</code></p> <p>A <code>JobRun</code> representing an Airbyte sync job.</p> Source code in <code>prefect_airbyte/connections.py</code> <pre><code>class AirbyteSync(JobRun):\n\"\"\"A `JobRun` representing an Airbyte sync job.\"\"\"\n\n    def __init__(self, airbyte_connection: \"AirbyteConnection\", job_id: int):\n        self.airbyte_connection: \"AirbyteConnection\" = airbyte_connection\n        self.job_id: int = job_id\n        self._records_synced: int = 0\n\n    @sync_compatible\n    async def wait_for_completion(self):\n\"\"\"Wait for the `AirbyteConnection` sync to reach a terminal state.\n\n        Raises:\n            AirbyteSyncJobFailed: If the sync job fails.\n        \"\"\"\n        async with self.airbyte_connection.airbyte_server.get_client(\n            logger=self.airbyte_connection.logger,\n            timeout=self.airbyte_connection.timeout,\n        ) as airbyte_client:\n\n            job_status = JOB_STATUS_PENDING\n\n            while job_status not in terminal_job_statuses:\n                job_info = await airbyte_client.get_job_info(self.job_id)\n\n                job_status = job_info[\"job\"][\"status\"]\n\n                self._records_synced = job_info[\"attempts\"][-1][\"attempt\"].get(\n                    \"recordsSynced\", 0\n                )\n\n                # pending\u2503running\u2503failed\u2503succeeded\u2503cancelled\n                if job_status == JOB_STATUS_SUCCEEDED:\n                    self.logger.info(f\"Job {self.job_id} succeeded.\")\n                elif job_status in [JOB_STATUS_FAILED, JOB_STATUS_CANCELLED]:\n                    self.logger.error(f\"Job {self.job_id} {job_status}.\")\n                    raise err.AirbyteSyncJobFailed(f\"Job {self.job_id} {job_status}.\")\n                else:\n                    if self.airbyte_connection.status_updates:\n                        self.logger.info(job_status)\n                    # wait for next poll interval\n                    await sleep(self.airbyte_connection.poll_interval_s)\n\n    @sync_compatible\n    async def fetch_result(self) -&gt; AirbyteSyncResult:\n\"\"\"Fetch the result of the `AirbyteSync`.\n\n        Returns:\n            `AirbyteSyncResult`: object containing metadata for the `AirbyteSync`.\n        \"\"\"\n        async with self.airbyte_connection.airbyte_server.get_client(\n            logger=self.airbyte_connection.logger,\n            timeout=self.airbyte_connection.timeout,\n        ) as airbyte_client:\n            job_info = await airbyte_client.get_job_info(self.job_id)\n\n            job_status = job_info[\"job\"][\"status\"]\n            job_created_at = job_info[\"job\"][\"createdAt\"]\n            job_updated_at = job_info[\"job\"][\"updatedAt\"]\n\n            return AirbyteSyncResult(\n                created_at=job_created_at,\n                job_id=self.job_id,\n                job_status=job_status,\n                records_synced=self._records_synced,\n                updated_at=job_updated_at,\n            )\n</code></pre>"},{"location":"connections/#prefect_airbyte.connections.AirbyteSync-functions","title":"Functions","text":""},{"location":"connections/#prefect_airbyte.connections.AirbyteSync.fetch_result","title":"<code>fetch_result</code>  <code>async</code>","text":"<p>Fetch the result of the <code>AirbyteSync</code>.</p> <p>Returns:</p> Type Description <code>AirbyteSyncResult</code> <p><code>AirbyteSyncResult</code>: object containing metadata for the <code>AirbyteSync</code>.</p> Source code in <code>prefect_airbyte/connections.py</code> <pre><code>@sync_compatible\nasync def fetch_result(self) -&gt; AirbyteSyncResult:\n\"\"\"Fetch the result of the `AirbyteSync`.\n\n    Returns:\n        `AirbyteSyncResult`: object containing metadata for the `AirbyteSync`.\n    \"\"\"\n    async with self.airbyte_connection.airbyte_server.get_client(\n        logger=self.airbyte_connection.logger,\n        timeout=self.airbyte_connection.timeout,\n    ) as airbyte_client:\n        job_info = await airbyte_client.get_job_info(self.job_id)\n\n        job_status = job_info[\"job\"][\"status\"]\n        job_created_at = job_info[\"job\"][\"createdAt\"]\n        job_updated_at = job_info[\"job\"][\"updatedAt\"]\n\n        return AirbyteSyncResult(\n            created_at=job_created_at,\n            job_id=self.job_id,\n            job_status=job_status,\n            records_synced=self._records_synced,\n            updated_at=job_updated_at,\n        )\n</code></pre>"},{"location":"connections/#prefect_airbyte.connections.AirbyteSync.wait_for_completion","title":"<code>wait_for_completion</code>  <code>async</code>","text":"<p>Wait for the <code>AirbyteConnection</code> sync to reach a terminal state.</p> <p>Raises:</p> Type Description <code>AirbyteSyncJobFailed</code> <p>If the sync job fails.</p> Source code in <code>prefect_airbyte/connections.py</code> <pre><code>@sync_compatible\nasync def wait_for_completion(self):\n\"\"\"Wait for the `AirbyteConnection` sync to reach a terminal state.\n\n    Raises:\n        AirbyteSyncJobFailed: If the sync job fails.\n    \"\"\"\n    async with self.airbyte_connection.airbyte_server.get_client(\n        logger=self.airbyte_connection.logger,\n        timeout=self.airbyte_connection.timeout,\n    ) as airbyte_client:\n\n        job_status = JOB_STATUS_PENDING\n\n        while job_status not in terminal_job_statuses:\n            job_info = await airbyte_client.get_job_info(self.job_id)\n\n            job_status = job_info[\"job\"][\"status\"]\n\n            self._records_synced = job_info[\"attempts\"][-1][\"attempt\"].get(\n                \"recordsSynced\", 0\n            )\n\n            # pending\u2503running\u2503failed\u2503succeeded\u2503cancelled\n            if job_status == JOB_STATUS_SUCCEEDED:\n                self.logger.info(f\"Job {self.job_id} succeeded.\")\n            elif job_status in [JOB_STATUS_FAILED, JOB_STATUS_CANCELLED]:\n                self.logger.error(f\"Job {self.job_id} {job_status}.\")\n                raise err.AirbyteSyncJobFailed(f\"Job {self.job_id} {job_status}.\")\n            else:\n                if self.airbyte_connection.status_updates:\n                    self.logger.info(job_status)\n                # wait for next poll interval\n                await sleep(self.airbyte_connection.poll_interval_s)\n</code></pre>"},{"location":"connections/#prefect_airbyte.connections.AirbyteSyncResult","title":"<code>AirbyteSyncResult</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Model representing a result from an <code>AirbyteSync</code> job run.</p> Source code in <code>prefect_airbyte/connections.py</code> <pre><code>class AirbyteSyncResult(BaseModel):\n\"\"\"Model representing a result from an `AirbyteSync` job run.\"\"\"\n\n    created_at: datetime\n    job_status: Literal[\"succeeded\", \"failed\", \"pending\", \"cancelled\"]\n    job_id: int\n    records_synced: int\n    updated_at: datetime\n</code></pre>"},{"location":"connections/#prefect_airbyte.connections-functions","title":"Functions","text":""},{"location":"connections/#prefect_airbyte.connections.trigger_sync","title":"<code>trigger_sync</code>  <code>async</code>","text":"<p>Prefect Task for triggering an Airbyte connection sync.</p> <p>It is assumed that the user will have previously configured a Source &amp; Destination into a Connection. e.g. MySql -&gt; CSV</p> <p>An invocation of <code>trigger_sync</code> will attempt to start a sync job for the specified <code>connection_id</code> representing the Connection in Airbyte.</p> <p><code>trigger_sync</code> will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call.</p> <p>As of <code>prefect-airbyte==0.1.3</code>, the kwargs <code>airbyte_server_host</code> and <code>airbyte_server_port</code> can be replaced by passing an <code>airbyte_server</code> block instance to generate the <code>AirbyteClient</code>. Using the <code>airbyte_server</code> block is preferred, but the individual kwargs remain for backwards compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>connection_id</code> <code>str</code> <p>Airbyte connection ID to trigger a sync for.</p> required <code>airbyte_server</code> <code>Optional[AirbyteServer]</code> <p>An <code>AirbyteServer</code> block to create an <code>AirbyteClient</code>.</p> <code>None</code> <code>airbyte_server_host</code> <code>Optional[str]</code> <p>Airbyte server host to connect to.</p> <code>None</code> <code>airbyte_server_port</code> <code>Optional[int]</code> <p>Airbyte server port to connect to.</p> <code>None</code> <code>airbyte_api_version</code> <code>Optional[str]</code> <p>Airbyte API version to use.</p> <code>None</code> <code>poll_interval_s</code> <code>int</code> <p>How often to poll Airbyte for sync status.</p> <code>15</code> <code>status_updates</code> <code>bool</code> <p>Whether to log sync job status while polling.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>The POST request <code>timeout</code> for the <code>httpx.AsyncClient</code>.</p> <code>5</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>connection_id</code> is not a valid UUID.</p> <code>AirbyteSyncJobFailed</code> <p>If airbyte returns <code>JOB_STATUS_FAILED</code>.</p> <code>AirbyteConnectionInactiveException</code> <p>If a given connection is inactive.</p> <code>AirbyeConnectionDeprecatedException</code> <p>If a given connection is deprecated.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Job metadata, including the connection ID and final status of the sync.</p> <p>Examples:</p> <p>Flow that triggers an Airybte connection sync: <pre><code>from prefect import flow\nfrom prefect_airbyte.connections import trigger_sync\nfrom prefect_airbyte.server import AirbyteServer\n@flow\ndef example_trigger_sync_flow():\n    # Run other tasks and subflows here\n    trigger_sync(\n        airbyte_server=AirbyteServer.load(\"oss-airbyte\"),\n        connection_id=\"your-connection-id-to-sync\"\n    )\nexample_trigger_sync_flow()\n</code></pre></p> Source code in <code>prefect_airbyte/connections.py</code> <pre><code>@task\nasync def trigger_sync(\n    connection_id: str,\n    airbyte_server: Optional[AirbyteServer] = None,\n    airbyte_server_host: Optional[str] = None,\n    airbyte_server_port: Optional[int] = None,\n    airbyte_api_version: Optional[str] = None,\n    poll_interval_s: int = 15,\n    status_updates: bool = False,\n    timeout: int = 5,\n) -&gt; Dict[str, Any]:\n\"\"\"Prefect Task for triggering an Airbyte connection sync.\n\n    *It is assumed that the user will have previously configured\n    a Source &amp; Destination into a Connection.*\n    e.g. MySql -&gt; CSV\n\n    An invocation of `trigger_sync` will attempt to start a sync job for\n    the specified `connection_id` representing the Connection in\n    Airbyte.\n\n    `trigger_sync` will poll Airbyte Server for the Connection status and\n    will only complete when the sync has completed or\n    when it receives an error status code from an API call.\n\n    As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and\n    `airbyte_server_port` can be replaced by passing an `airbyte_server` block\n    instance to generate the `AirbyteClient`. Using the `airbyte_server` block is\n    preferred, but the individual kwargs remain for backwards compatibility.\n\n    Args:\n        connection_id: Airbyte connection ID to trigger a sync for.\n        airbyte_server: An `AirbyteServer` block to create an `AirbyteClient`.\n        airbyte_server_host: Airbyte server host to connect to.\n        airbyte_server_port: Airbyte server port to connect to.\n        airbyte_api_version: Airbyte API version to use.\n        poll_interval_s: How often to poll Airbyte for sync status.\n        status_updates: Whether to log sync job status while polling.\n        timeout: The POST request `timeout` for the `httpx.AsyncClient`.\n    Raises:\n        ValueError: If `connection_id` is not a valid UUID.\n        AirbyteSyncJobFailed: If airbyte returns `JOB_STATUS_FAILED`.\n        AirbyteConnectionInactiveException: If a given connection is inactive.\n        AirbyeConnectionDeprecatedException: If a given connection is deprecated.\n    Returns:\n        Job metadata, including the connection ID and final status of the sync.\n    Examples:\n        Flow that triggers an Airybte connection sync:\n        ```python\n        from prefect import flow\n        from prefect_airbyte.connections import trigger_sync\n        from prefect_airbyte.server import AirbyteServer\n        @flow\n        def example_trigger_sync_flow():\n            # Run other tasks and subflows here\n            trigger_sync(\n                airbyte_server=AirbyteServer.load(\"oss-airbyte\"),\n                connection_id=\"your-connection-id-to-sync\"\n            )\n        example_trigger_sync_flow()\n        ```\n    \"\"\"\n    logger = get_run_logger()\n\n    if not airbyte_server:\n        warn(\n            \"The use of `airbyte_server_host`, `airbyte_server_port`, and \"\n            \"`airbyte_api_version` is deprecated and will be removed in a \"\n            \"future release. Please pass an `airbyte_server` block to this \"\n            \"task instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        if any([airbyte_server_host, airbyte_server_port, airbyte_api_version]):\n            airbyte_server = AirbyteServer(\n                server_host=airbyte_server_host or \"localhost\",\n                server_port=airbyte_server_port or 8000,\n                api_version=airbyte_api_version or \"v1\",\n            )\n        else:\n            airbyte_server = AirbyteServer()\n    else:\n        if any([airbyte_server_host, airbyte_server_port, airbyte_api_version]):\n            logger.info(\n                \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \"\n                \"and `airbyte_server_port` because `airbyte_server` block \"\n                \" was passed. Using API URL from `airbyte_server` block: \"\n                f\"{airbyte_server.base_url!r}.\"\n            )\n\n    try:\n        uuid.UUID(connection_id)\n    except (TypeError, ValueError):\n        raise ValueError(\n            \"Parameter `connection_id` *must* be a valid UUID \\\n            i.e. 32 hex characters, including hyphens.\"\n        )\n\n    async with airbyte_server.get_client(\n        logger=logger, timeout=timeout\n    ) as airbyte_client:\n\n        logger.info(\n            f\"Getting Airbyte Connection {connection_id}, poll interval \"\n            f\"{poll_interval_s} seconds, airbyte_base_url {airbyte_server.base_url}\"\n        )\n\n        connection_status = await airbyte_client.get_connection_status(connection_id)\n\n        if connection_status == CONNECTION_STATUS_ACTIVE:\n            # Trigger manual sync on the Connection ...\n            (\n                job_id,\n                job_created_at,\n            ) = await airbyte_client.trigger_manual_sync_connection(connection_id)\n\n            job_status = JOB_STATUS_PENDING\n\n            while job_status not in terminal_job_statuses:\n                (\n                    job_status,\n                    job_created_at,\n                    job_updated_at,\n                ) = await airbyte_client.get_job_status(job_id)\n\n                # pending\u2503running\u2503incomplete\u2503failed\u2503succeeded\u2503cancelled\n                if job_status == JOB_STATUS_SUCCEEDED:\n                    logger.info(f\"Job {job_id} succeeded.\")\n                elif job_status in [JOB_STATUS_FAILED, JOB_STATUS_CANCELLED]:\n                    logger.error(f\"Job {job_id} {job_status}.\")\n                    raise err.AirbyteSyncJobFailed(f\"Job {job_id} {job_status}.\")\n                else:\n                    if status_updates:\n                        logger.info(job_status)\n                    # wait for next poll interval\n                    await sleep(poll_interval_s)\n\n            return {\n                \"connection_id\": connection_id,\n                \"status\": connection_status,\n                \"job_status\": job_status,\n                \"job_created_at\": job_created_at,\n                \"job_updated_at\": job_updated_at,\n            }\n        elif connection_status == CONNECTION_STATUS_INACTIVE:\n            logger.error(\n                f\"Connection: {connection_id} is inactive\"\n                \" - you'll need to enable it in your Airbyte instance\"\n            )\n            raise err.AirbyteConnectionInactiveException(\n                f\"Please enable the Connection {connection_id} in Airbyte instance.\"\n            )\n        elif connection_status == CONNECTION_STATUS_DEPRECATED:\n            logger.error(f\"Connection {connection_id} is deprecated.\")\n            raise err.AirbyeConnectionDeprecatedException(\n                f\"Connection {connection_id} is deprecated.\"\n            )\n</code></pre>"},{"location":"exceptions/","title":"Exceptions","text":""},{"location":"exceptions/#prefect_airbyte.exceptions","title":"<code>prefect_airbyte.exceptions</code>","text":"<p>Exceptions to raise indicating issues throughout prefect_airbyte</p>"},{"location":"exceptions/#prefect_airbyte.exceptions-classes","title":"Classes","text":""},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyeConnectionDeprecatedException","title":"<code>AirbyeConnectionDeprecatedException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when a specified Airbyte connection is deprecated.</p> Source code in <code>prefect_airbyte/exceptions.py</code> <pre><code>class AirbyeConnectionDeprecatedException(Exception):\n\"\"\"\n    Raises when a specified Airbyte connection is deprecated.\n    \"\"\"\n</code></pre>"},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyteConnectionInactiveException","title":"<code>AirbyteConnectionInactiveException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when a specified Airbyte connection is inactive.</p> Source code in <code>prefect_airbyte/exceptions.py</code> <pre><code>class AirbyteConnectionInactiveException(Exception):\n\"\"\"\n    Raises when a specified Airbyte connection is inactive.\n    \"\"\"\n</code></pre>"},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyteExportConfigurationFailed","title":"<code>AirbyteExportConfigurationFailed</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when an Airbyte configuration export fails.</p> Source code in <code>prefect_airbyte/exceptions.py</code> <pre><code>class AirbyteExportConfigurationFailed(Exception):\n\"\"\"\n    Raises when an Airbyte configuration export fails.\n    \"\"\"\n</code></pre>"},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyteServerNotHealthyException","title":"<code>AirbyteServerNotHealthyException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when a specified Airbyte instance returns an unhealthy response.</p> Source code in <code>prefect_airbyte/exceptions.py</code> <pre><code>class AirbyteServerNotHealthyException(Exception):\n\"\"\"\n    Raises when a specified Airbyte instance returns an unhealthy response.\n    \"\"\"\n</code></pre>"},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyteSyncJobFailed","title":"<code>AirbyteSyncJobFailed</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when a specified Airbyte Sync Job fails.</p> Source code in <code>prefect_airbyte/exceptions.py</code> <pre><code>class AirbyteSyncJobFailed(Exception):\n\"\"\"\n    Raises when a specified Airbyte Sync Job fails.\n    \"\"\"\n</code></pre>"},{"location":"exceptions/#prefect_airbyte.exceptions.ConnectionNotFoundException","title":"<code>ConnectionNotFoundException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when a requested Airbyte connection cannot be found.</p> Source code in <code>prefect_airbyte/exceptions.py</code> <pre><code>class ConnectionNotFoundException(Exception):\n\"\"\"\n    Raises when a requested Airbyte connection cannot be found.\n    \"\"\"\n</code></pre>"},{"location":"exceptions/#prefect_airbyte.exceptions.JobNotFoundException","title":"<code>JobNotFoundException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when a requested Airbyte job cannot be found.</p> Source code in <code>prefect_airbyte/exceptions.py</code> <pre><code>class JobNotFoundException(Exception):\n\"\"\"\n    Raises when a requested Airbyte job cannot be found.\n    \"\"\"\n</code></pre>"},{"location":"flows/","title":"Flows","text":""},{"location":"flows/#prefect_airbyte.flows","title":"<code>prefect_airbyte.flows</code>","text":"<p>Flows for interacting with Airbyte.</p>"},{"location":"flows/#prefect_airbyte.flows-classes","title":"Classes","text":""},{"location":"flows/#prefect_airbyte.flows-functions","title":"Functions","text":""},{"location":"flows/#prefect_airbyte.flows.run_connection_sync","title":"<code>run_connection_sync</code>  <code>async</code>","text":"<p>A flow that triggers a sync of an Airbyte connection and waits for it to complete.</p> <p>Parameters:</p> Name Type Description Default <code>airbyte_connection</code> <code>AirbyteConnection</code> <p><code>AirbyteConnection</code> representing the Airbyte connection to trigger and wait for completion of.</p> required <p>Returns:</p> Type Description <code>AirbyteSyncResult</code> <p><code>AirbyteSyncResult</code>: Model containing metadata for the <code>AirbyteSync</code>.</p> Example <p>Define a flow that runs an Airbyte connection sync: <pre><code>from prefect import flow\nfrom prefect_airbyte.server import AirbyteServer\nfrom prefect_airbyte.connections import AirbyteConnection\nfrom prefect_airbyte.flows import run_connection_sync\n\nairbyte_server = AirbyteServer(\n    server_host=\"localhost\",\n    server_port=8000\n)\n\nconnection = AirbyteConnection(\n    airbyte_server=airbyte_server,\n    connection_id=\"&lt;YOUR-AIRBYTE-CONNECTION-UUID&gt;\"\n)\n\n@flow\ndef airbyte_sync_flow():\n    # do some things\n\n    airbyte_sync_result = run_connection_sync(\n        airbyte_connection=connection\n    )\n    print(airbyte_sync_result.records_synced)\n\n    # do some other things, like trigger DBT based on number of new raw records\n</code></pre></p> Source code in <code>prefect_airbyte/flows.py</code> <pre><code>@flow\nasync def run_connection_sync(\n    airbyte_connection: AirbyteConnection,\n) -&gt; AirbyteSyncResult:\n\"\"\"A flow that triggers a sync of an Airbyte connection and waits for it to complete.\n\n    Args:\n        airbyte_connection: `AirbyteConnection` representing the Airbyte connection to\n            trigger and wait for completion of.\n\n    Returns:\n        `AirbyteSyncResult`: Model containing metadata for the `AirbyteSync`.\n\n    Example:\n        Define a flow that runs an Airbyte connection sync:\n        ```python\n        from prefect import flow\n        from prefect_airbyte.server import AirbyteServer\n        from prefect_airbyte.connections import AirbyteConnection\n        from prefect_airbyte.flows import run_connection_sync\n\n        airbyte_server = AirbyteServer(\n            server_host=\"localhost\",\n            server_port=8000\n        )\n\n        connection = AirbyteConnection(\n            airbyte_server=airbyte_server,\n            connection_id=\"&lt;YOUR-AIRBYTE-CONNECTION-UUID&gt;\"\n        )\n\n        @flow\n        def airbyte_sync_flow():\n            # do some things\n\n            airbyte_sync_result = run_connection_sync(\n                airbyte_connection=connection\n            )\n            print(airbyte_sync_result.records_synced)\n\n            # do some other things, like trigger DBT based on number of new raw records\n        ```\n    \"\"\"\n\n    # TODO: refactor block method calls to avoid using &lt;sync_compatible_method&gt;.aio\n    # we currently need to do this because of the deadlock caused by calling\n    # a sync task within an async flow\n    # see [this issue](https://github.com/PrefectHQ/prefect/issues/7551)\n\n    airbyte_sync = await task(airbyte_connection.trigger.aio)(airbyte_connection)\n\n    await task(airbyte_sync.wait_for_completion.aio)(airbyte_sync)\n\n    return await task(airbyte_sync.fetch_result.aio)(airbyte_sync)\n</code></pre>"},{"location":"server/","title":"Server","text":""},{"location":"server/#prefect_airbyte.server","title":"<code>prefect_airbyte.server</code>","text":"<p>A module for defining OSS Airbyte interactions with Prefect.</p>"},{"location":"server/#prefect_airbyte.server-classes","title":"Classes","text":""},{"location":"server/#prefect_airbyte.server.AirbyteServer","title":"<code>AirbyteServer</code>","text":"<p>         Bases: <code>Block</code></p> <p>A block representing an Airbyte server for generating <code>AirbyteClient</code> instances.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>Username for Airbyte API.</p> <code>password</code> <code>SecretStr</code> <p>Password for Airbyte API.</p> <code>server_host</code> <code>str</code> <p>Hostname for Airbyte API.</p> <code>server_port</code> <code>int</code> <p>Port for Airbyte API.</p> <code>api_version</code> <code>str</code> <p>Version of Airbyte API to use.</p> <code>use_ssl</code> <code>bool</code> <p>Whether to use a secure url for calls to the Airbyte API.</p> Example <pre><code>from prefect_airbyte.server import AirbyteServer\n\nserver = AirbyteServer.load(\"BLOCK_NAME\")\n</code></pre> Source code in <code>prefect_airbyte/server.py</code> <pre><code>class AirbyteServer(Block):\n\"\"\"A block representing an Airbyte server for generating `AirbyteClient` instances.\n\n    Attributes:\n        username: Username for Airbyte API.\n        password: Password for Airbyte API.\n        server_host: Hostname for Airbyte API.\n        server_port: Port for Airbyte API.\n        api_version: Version of Airbyte API to use.\n        use_ssl: Whether to use a secure url for calls to the Airbyte API.\n\n    Example:\n        ```python\n        from prefect_airbyte.server import AirbyteServer\n\n        server = AirbyteServer.load(\"BLOCK_NAME\")\n        ```\n    \"\"\"\n\n    _block_type_name = \"Airbyte Server\"\n    _block_type_slug = \"airbyte-server\"\n    _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/6gm7wsC7ANnKYQsm7oiSYz/aac1ad5e054d35d9e24af8d6ed3aed5f/59758427?h=250\"  # noqa\n    _documentation_url = \"https://prefecthq.github.io/prefect-airbyte/server/#prefect_airbyte.server.AirbyteServer\"  # noqa\n\n    username: str = Field(\n        default=\"airbyte\",\n        description=\"Username to authenticate with Airbyte API.\",\n    )\n\n    password: SecretStr = Field(\n        default=SecretStr(\"password\"),\n        description=\"Password to authenticate with Airbyte API.\",\n    )\n\n    server_host: str = Field(\n        default=\"localhost\",\n        description=\"Host address of Airbyte server.\",\n        example=\"127.0.0.1\",\n    )\n\n    server_port: int = Field(\n        default=8000,\n        description=\"Port number of Airbyte server.\",\n    )\n\n    api_version: str = Field(\n        default=\"v1\",\n        description=\"Airbyte API version to use.\",\n        title=\"API Version\",\n    )\n\n    use_ssl: bool = Field(\n        default=False,\n        description=\"Whether to use SSL when connecting to Airbyte server.\",\n        title=\"Use SSL\",\n    )\n\n    @property\n    def base_url(self) -&gt; str:\n\"\"\"Property containing the base URL for the Airbyte API.\"\"\"\n        protocol = \"https\" if self.use_ssl else \"http\"\n        return (\n            f\"{protocol}://{self.server_host}:{self.server_port}/api/{self.api_version}\"\n        )\n\n    def get_client(self, logger: Logger, timeout: int = 10) -&gt; AirbyteClient:\n\"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API.\n\n        Args:\n            logger: Logger instance used to log messages related to API calls.\n            timeout: The number of seconds to wait before an API call times out.\n\n        Returns:\n            An `AirbyteClient` instance.\n        \"\"\"\n        return AirbyteClient(\n            logger=logger,\n            airbyte_base_url=self.base_url,\n            auth=(self.username, self.password.get_secret_value()),\n            timeout=timeout,\n        )\n</code></pre>"},{"location":"server/#prefect_airbyte.server.AirbyteServer-attributes","title":"Attributes","text":""},{"location":"server/#prefect_airbyte.server.AirbyteServer.base_url","title":"<code>base_url: str</code>  <code>property</code>","text":"<p>Property containing the base URL for the Airbyte API.</p>"},{"location":"server/#prefect_airbyte.server.AirbyteServer-functions","title":"Functions","text":""},{"location":"server/#prefect_airbyte.server.AirbyteServer.get_client","title":"<code>get_client</code>","text":"<p>Returns an <code>AirbyteClient</code> instance for interacting with the Airbyte API.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>Logger instance used to log messages related to API calls.</p> required <code>timeout</code> <code>int</code> <p>The number of seconds to wait before an API call times out.</p> <code>10</code> <p>Returns:</p> Type Description <code>AirbyteClient</code> <p>An <code>AirbyteClient</code> instance.</p> Source code in <code>prefect_airbyte/server.py</code> <pre><code>def get_client(self, logger: Logger, timeout: int = 10) -&gt; AirbyteClient:\n\"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API.\n\n    Args:\n        logger: Logger instance used to log messages related to API calls.\n        timeout: The number of seconds to wait before an API call times out.\n\n    Returns:\n        An `AirbyteClient` instance.\n    \"\"\"\n    return AirbyteClient(\n        logger=logger,\n        airbyte_base_url=self.base_url,\n        auth=(self.username, self.password.get_secret_value()),\n        timeout=timeout,\n    )\n</code></pre>"}]}