{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"prefect-airbyte Welcome! prefect-airbyte is a collection of prebuilt Prefect tasks that can be used to quickly construct Prefect flows to trigger Airbyte syncs or export your connector configurations. Getting Started Python setup Requires an installation of Python 3.7+ We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation . Installation Install prefect-airbyte pip install prefect-airbyte Airbyte setup See the airbyte documention on how to get your own instance. Examples Trigger a defined connection sync from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( connection_id = \"your-connection-id-to-sync\" , poll_interval_s = 3 , status_updates = True ) example_trigger_sync_flow () \u276f python airbyte_syncs.py 03:46:03 | prefect.engine - Created flow run 'thick-seahorse' for flow 'example_trigger_sync_flow' 03:46:03 | Flow run 'thick-seahorse' - Using task runner 'ConcurrentTaskRunner' 03:46:03 | Flow run 'thick-seahorse' - Created task run 'trigger_sync-35f0e9c2-0' for task 'trigger_sync' 03:46:03 | prefect - trigger airbyte connection: e1b2078f-882a-4f50-9942-cfe34b2d825b, poll interval 3 seconds 03:46:03 | prefect - pending 03:46:06 | prefect - running 03:46:09 | prefect - running 03:46:12 | prefect - running 03:46:16 | prefect - running 03:46:19 | prefect - running 03:46:22 | prefect - Job 26 succeeded. 03:46:22 | Task run 'trigger_sync-35f0e9c2-0' - Finished in state Completed(None) 03:46:22 | Flow run 'thick-seahorse' - Finished in state Completed('All states completed.') Export an Airbyte instance's configuration import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere ( airbyte_config : bytearray , somewhere : str , ): with gzip . open ( somewhere , 'wb' ) as f : f . write ( airbyte_config ) @flow def example_export_configuration_flow ( filepath : str ): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server_host = \"localhost\" , airbyte_server_port = \"8000\" , airbyte_api_version = \"v1\" , ) zip_and_write_somewhere ( somewhere = filepath , airbyte_config = airbyte_config ) if __name__ == \"__main__\" : example_export_configuration_flow ( '*://**/my_destination.gz' ) Resources If you encounter and bugs while using prefect-airbyte , feel free to open an issue in the prefect-airbyte repository. If you have any questions or issues while using prefect-airbyte , you can find help in either the Prefect Discourse forum or the Prefect Slack community Development If you'd like to install a version of prefect-airbyte for development, first clone the repository and then perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-airbyte.git cd prefect-airbyte/ pip install -e \".[dev]\"","title":"Home"},{"location":"#prefect-airbyte","text":"","title":"prefect-airbyte"},{"location":"#welcome","text":"prefect-airbyte is a collection of prebuilt Prefect tasks that can be used to quickly construct Prefect flows to trigger Airbyte syncs or export your connector configurations.","title":"Welcome!"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#python-setup","text":"Requires an installation of Python 3.7+ We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation .","title":"Python setup"},{"location":"#installation","text":"Install prefect-airbyte pip install prefect-airbyte","title":"Installation"},{"location":"#airbyte-setup","text":"See the airbyte documention on how to get your own instance.","title":"Airbyte setup"},{"location":"#examples","text":"","title":"Examples"},{"location":"#trigger-a-defined-connection-sync","text":"from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( connection_id = \"your-connection-id-to-sync\" , poll_interval_s = 3 , status_updates = True ) example_trigger_sync_flow () \u276f python airbyte_syncs.py 03:46:03 | prefect.engine - Created flow run 'thick-seahorse' for flow 'example_trigger_sync_flow' 03:46:03 | Flow run 'thick-seahorse' - Using task runner 'ConcurrentTaskRunner' 03:46:03 | Flow run 'thick-seahorse' - Created task run 'trigger_sync-35f0e9c2-0' for task 'trigger_sync' 03:46:03 | prefect - trigger airbyte connection: e1b2078f-882a-4f50-9942-cfe34b2d825b, poll interval 3 seconds 03:46:03 | prefect - pending 03:46:06 | prefect - running 03:46:09 | prefect - running 03:46:12 | prefect - running 03:46:16 | prefect - running 03:46:19 | prefect - running 03:46:22 | prefect - Job 26 succeeded. 03:46:22 | Task run 'trigger_sync-35f0e9c2-0' - Finished in state Completed(None) 03:46:22 | Flow run 'thick-seahorse' - Finished in state Completed('All states completed.')","title":"Trigger a defined connection sync"},{"location":"#export-an-airbyte-instances-configuration","text":"import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere ( airbyte_config : bytearray , somewhere : str , ): with gzip . open ( somewhere , 'wb' ) as f : f . write ( airbyte_config ) @flow def example_export_configuration_flow ( filepath : str ): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server_host = \"localhost\" , airbyte_server_port = \"8000\" , airbyte_api_version = \"v1\" , ) zip_and_write_somewhere ( somewhere = filepath , airbyte_config = airbyte_config ) if __name__ == \"__main__\" : example_export_configuration_flow ( '*://**/my_destination.gz' )","title":"Export an Airbyte instance's configuration"},{"location":"#resources","text":"If you encounter and bugs while using prefect-airbyte , feel free to open an issue in the prefect-airbyte repository. If you have any questions or issues while using prefect-airbyte , you can find help in either the Prefect Discourse forum or the Prefect Slack community","title":"Resources"},{"location":"#development","text":"If you'd like to install a version of prefect-airbyte for development, first clone the repository and then perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-airbyte.git cd prefect-airbyte/ pip install -e \".[dev]\"","title":"Development"},{"location":"client/","text":"prefect_airbyte.client Client for interacting with Airbyte instance AirbyteClient Esablishes a client session with an Airbyte instance and evaluates its current health status. This client assumes that you're using Airbyte Open-Source, since \"For Airbyte Open-Source you don't need the API Token for Authentication! All endpoints are accessible using the API without it.\" For more info, see the Airbyte docs . Parameters: Name Type Description Default airbyte_base_url str base api endpoint url for airbyte 'http://localhost:8000/api/v1' Returns: Name Type Description AirbyteClient an instance of AirbyteClient Source code in prefect_airbyte/client.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class AirbyteClient : \"\"\" Esablishes a client session with an Airbyte instance and evaluates its current health status. This client assumes that you're using Airbyte Open-Source, since \"For Airbyte Open-Source you don't need the API Token for Authentication! All endpoints are accessible using the API without it.\" For more info, see the [Airbyte docs](https://docs.airbyte.io/api-documentation). Args: airbyte_base_url str: base api endpoint url for airbyte Returns: AirbyteClient: an instance of AirbyteClient \"\"\" def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , timeout : int = 5 , ) -> None : \"\"\" `AirbyteClient` constructor Args: logger: for client use, e.g. `prefect.logging.loggers.get_logger` airbyte_base_url: Full Airbyte API endpoint timeout: seconds for httpx client timeout Returns: AirbyteClient: an instance of the `AirbyteClient` class \"\"\" self . airbyte_base_url = airbyte_base_url self . logger = logger self . timeout = timeout async def _establish_session ( self ) -> httpx . AsyncClient : \"\"\" AirbyteClient method to `check_health_status` and establish a `client` session Returns: client: `httpx.AsyncClient` used to communicate with the Airbyte API \"\"\" client = httpx . AsyncClient ( timeout = self . timeout ) if await self . check_health_status ( client ): return client else : raise err . AirbyteServerNotHealthyException async def check_health_status ( self , client : httpx . AsyncClient ): \"\"\" Check the health status of an AirbyteInstance Args: client: `httpx.AsyncClient` instance used to interact with the Airbyte API Returns: bool: representing whether the server is healthy \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e ) async def create_client ( self ) -> httpx . AsyncClient : \"\"\" Convenience method for establishing a healthy `httpx` Airbyte client Args: timeout: `int` seconds for request timeout with this client Returns: httpx.AsyncClient: client for interacting with Airbyte instance \"\"\" client = await self . _establish_session () return client async def export_configuration ( self , ) -> bytearray : \"\"\" Trigger an export of Airbyte configuration Args: client: httpx client with which to make call to the Airbyte server Returns: byte array of Airbyte configuration data \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await client . post ( get_connection_url ) if response . status_code == 200 : self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : raise err . AirbyteExportConfigurationFailed ( e ) async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Get the status of a defined Airbyte connection Args: connection_id: string value of the defined airbyte connection Returns: str: the status of a defined Airbyte connection \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/get/\" # TODO - Missing auth because Airbyte API currently doesn't yet support auth try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException else : raise err . AirbyteServerNotHealthyException ( e ) async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Trigger a manual sync of the Connection Args: connection_id: ID of connection to sync Returns: created_at - timestamp of sync job creation \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/sync/\" # TODO - no current authentication methods from Airbyte try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) if response . status_code == 200 : job_id = response . json ()[ \"job\" ][ \"id\" ] print ( response . json ()) job_created_at = response . json ()[ \"job\" ][ \"createdAt\" ] return job_id , job_created_at elif response . status_code == 404 : # connection_id not found self . logger . warning ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id ...\" ) raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id ...\" ) except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e ) async def get_job_status ( self , job_id : str ) -> str : \"\"\" Get the status of an Airbyte connection sync job Args: job_id: str value of the airbyte job id as defined by airbyte Returns: byte array of Airbyte configuration data \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await client . post ( get_connection_url , json = { \"id\" : job_id }) if response . status_code == 200 : job_status = response . json ()[ \"job\" ][ \"status\" ] job_created_at = response . json ()[ \"job\" ][ \"createdAt\" ] job_updated_at = response . json ()[ \"job\" ][ \"updatedAt\" ] return job_status , job_created_at , job_updated_at elif response . status_code == 404 : self . logger . error ( f \"Job { job_id } not found...\" ) raise err . JobNotFoundException ( f \"Job { job_id } not found...\" ) except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e ) __init__ AirbyteClient constructor Parameters: Name Type Description Default logger logging . Logger for client use, e.g. prefect.logging.loggers.get_logger required airbyte_base_url str Full Airbyte API endpoint 'http://localhost:8000/api/v1' timeout int seconds for httpx client timeout 5 Returns: Name Type Description AirbyteClient None an instance of the AirbyteClient class Source code in prefect_airbyte/client.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , timeout : int = 5 , ) -> None : \"\"\" `AirbyteClient` constructor Args: logger: for client use, e.g. `prefect.logging.loggers.get_logger` airbyte_base_url: Full Airbyte API endpoint timeout: seconds for httpx client timeout Returns: AirbyteClient: an instance of the `AirbyteClient` class \"\"\" self . airbyte_base_url = airbyte_base_url self . logger = logger self . timeout = timeout check_health_status async Check the health status of an AirbyteInstance Parameters: Name Type Description Default client httpx . AsyncClient httpx.AsyncClient instance used to interact with the Airbyte API required Returns: Name Type Description bool representing whether the server is healthy Source code in prefect_airbyte/client.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 async def check_health_status ( self , client : httpx . AsyncClient ): \"\"\" Check the health status of an AirbyteInstance Args: client: `httpx.AsyncClient` instance used to interact with the Airbyte API Returns: bool: representing whether the server is healthy \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e ) create_client async Convenience method for establishing a healthy httpx Airbyte client Parameters: Name Type Description Default timeout int seconds for request timeout with this client required Returns: Type Description httpx . AsyncClient httpx.AsyncClient: client for interacting with Airbyte instance Source code in prefect_airbyte/client.py 87 88 89 90 91 92 93 94 95 96 97 async def create_client ( self ) -> httpx . AsyncClient : \"\"\" Convenience method for establishing a healthy `httpx` Airbyte client Args: timeout: `int` seconds for request timeout with this client Returns: httpx.AsyncClient: client for interacting with Airbyte instance \"\"\" client = await self . _establish_session () return client export_configuration async Trigger an export of Airbyte configuration Parameters: Name Type Description Default client httpx client with which to make call to the Airbyte server required Returns: Type Description bytearray byte array of Airbyte configuration data Source code in prefect_airbyte/client.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 async def export_configuration ( self , ) -> bytearray : \"\"\" Trigger an export of Airbyte configuration Args: client: httpx client with which to make call to the Airbyte server Returns: byte array of Airbyte configuration data \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await client . post ( get_connection_url ) if response . status_code == 200 : self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : raise err . AirbyteExportConfigurationFailed ( e ) get_connection_status async Get the status of a defined Airbyte connection Parameters: Name Type Description Default connection_id str string value of the defined airbyte connection required Returns: Name Type Description str str the status of a defined Airbyte connection Source code in prefect_airbyte/client.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Get the status of a defined Airbyte connection Args: connection_id: string value of the defined airbyte connection Returns: str: the status of a defined Airbyte connection \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/get/\" # TODO - Missing auth because Airbyte API currently doesn't yet support auth try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException else : raise err . AirbyteServerNotHealthyException ( e ) get_job_status async Get the status of an Airbyte connection sync job Parameters: Name Type Description Default job_id str str value of the airbyte job id as defined by airbyte required Returns: Type Description str byte array of Airbyte configuration data Source code in prefect_airbyte/client.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 async def get_job_status ( self , job_id : str ) -> str : \"\"\" Get the status of an Airbyte connection sync job Args: job_id: str value of the airbyte job id as defined by airbyte Returns: byte array of Airbyte configuration data \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await client . post ( get_connection_url , json = { \"id\" : job_id }) if response . status_code == 200 : job_status = response . json ()[ \"job\" ][ \"status\" ] job_created_at = response . json ()[ \"job\" ][ \"createdAt\" ] job_updated_at = response . json ()[ \"job\" ][ \"updatedAt\" ] return job_status , job_created_at , job_updated_at elif response . status_code == 404 : self . logger . error ( f \"Job { job_id } not found...\" ) raise err . JobNotFoundException ( f \"Job { job_id } not found...\" ) except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e ) trigger_manual_sync_connection async Trigger a manual sync of the Connection Parameters: Name Type Description Default connection_id str ID of connection to sync required Source code in prefect_airbyte/client.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Trigger a manual sync of the Connection Args: connection_id: ID of connection to sync Returns: created_at - timestamp of sync job creation \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/sync/\" # TODO - no current authentication methods from Airbyte try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) if response . status_code == 200 : job_id = response . json ()[ \"job\" ][ \"id\" ] print ( response . json ()) job_created_at = response . json ()[ \"job\" ][ \"createdAt\" ] return job_id , job_created_at elif response . status_code == 404 : # connection_id not found self . logger . warning ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id ...\" ) raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id ...\" ) except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e )","title":"Client"},{"location":"client/#prefect_airbyte.client","text":"Client for interacting with Airbyte instance","title":"client"},{"location":"client/#prefect_airbyte.client.AirbyteClient","text":"Esablishes a client session with an Airbyte instance and evaluates its current health status. This client assumes that you're using Airbyte Open-Source, since \"For Airbyte Open-Source you don't need the API Token for Authentication! All endpoints are accessible using the API without it.\" For more info, see the Airbyte docs . Parameters: Name Type Description Default airbyte_base_url str base api endpoint url for airbyte 'http://localhost:8000/api/v1' Returns: Name Type Description AirbyteClient an instance of AirbyteClient Source code in prefect_airbyte/client.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class AirbyteClient : \"\"\" Esablishes a client session with an Airbyte instance and evaluates its current health status. This client assumes that you're using Airbyte Open-Source, since \"For Airbyte Open-Source you don't need the API Token for Authentication! All endpoints are accessible using the API without it.\" For more info, see the [Airbyte docs](https://docs.airbyte.io/api-documentation). Args: airbyte_base_url str: base api endpoint url for airbyte Returns: AirbyteClient: an instance of AirbyteClient \"\"\" def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , timeout : int = 5 , ) -> None : \"\"\" `AirbyteClient` constructor Args: logger: for client use, e.g. `prefect.logging.loggers.get_logger` airbyte_base_url: Full Airbyte API endpoint timeout: seconds for httpx client timeout Returns: AirbyteClient: an instance of the `AirbyteClient` class \"\"\" self . airbyte_base_url = airbyte_base_url self . logger = logger self . timeout = timeout async def _establish_session ( self ) -> httpx . AsyncClient : \"\"\" AirbyteClient method to `check_health_status` and establish a `client` session Returns: client: `httpx.AsyncClient` used to communicate with the Airbyte API \"\"\" client = httpx . AsyncClient ( timeout = self . timeout ) if await self . check_health_status ( client ): return client else : raise err . AirbyteServerNotHealthyException async def check_health_status ( self , client : httpx . AsyncClient ): \"\"\" Check the health status of an AirbyteInstance Args: client: `httpx.AsyncClient` instance used to interact with the Airbyte API Returns: bool: representing whether the server is healthy \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e ) async def create_client ( self ) -> httpx . AsyncClient : \"\"\" Convenience method for establishing a healthy `httpx` Airbyte client Args: timeout: `int` seconds for request timeout with this client Returns: httpx.AsyncClient: client for interacting with Airbyte instance \"\"\" client = await self . _establish_session () return client async def export_configuration ( self , ) -> bytearray : \"\"\" Trigger an export of Airbyte configuration Args: client: httpx client with which to make call to the Airbyte server Returns: byte array of Airbyte configuration data \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await client . post ( get_connection_url ) if response . status_code == 200 : self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : raise err . AirbyteExportConfigurationFailed ( e ) async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Get the status of a defined Airbyte connection Args: connection_id: string value of the defined airbyte connection Returns: str: the status of a defined Airbyte connection \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/get/\" # TODO - Missing auth because Airbyte API currently doesn't yet support auth try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException else : raise err . AirbyteServerNotHealthyException ( e ) async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Trigger a manual sync of the Connection Args: connection_id: ID of connection to sync Returns: created_at - timestamp of sync job creation \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/sync/\" # TODO - no current authentication methods from Airbyte try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) if response . status_code == 200 : job_id = response . json ()[ \"job\" ][ \"id\" ] print ( response . json ()) job_created_at = response . json ()[ \"job\" ][ \"createdAt\" ] return job_id , job_created_at elif response . status_code == 404 : # connection_id not found self . logger . warning ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id ...\" ) raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id ...\" ) except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e ) async def get_job_status ( self , job_id : str ) -> str : \"\"\" Get the status of an Airbyte connection sync job Args: job_id: str value of the airbyte job id as defined by airbyte Returns: byte array of Airbyte configuration data \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await client . post ( get_connection_url , json = { \"id\" : job_id }) if response . status_code == 200 : job_status = response . json ()[ \"job\" ][ \"status\" ] job_created_at = response . json ()[ \"job\" ][ \"createdAt\" ] job_updated_at = response . json ()[ \"job\" ][ \"updatedAt\" ] return job_status , job_created_at , job_updated_at elif response . status_code == 404 : self . logger . error ( f \"Job { job_id } not found...\" ) raise err . JobNotFoundException ( f \"Job { job_id } not found...\" ) except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e )","title":"AirbyteClient"},{"location":"client/#prefect_airbyte.client.AirbyteClient.__init__","text":"AirbyteClient constructor Parameters: Name Type Description Default logger logging . Logger for client use, e.g. prefect.logging.loggers.get_logger required airbyte_base_url str Full Airbyte API endpoint 'http://localhost:8000/api/v1' timeout int seconds for httpx client timeout 5 Returns: Name Type Description AirbyteClient None an instance of the AirbyteClient class Source code in prefect_airbyte/client.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , timeout : int = 5 , ) -> None : \"\"\" `AirbyteClient` constructor Args: logger: for client use, e.g. `prefect.logging.loggers.get_logger` airbyte_base_url: Full Airbyte API endpoint timeout: seconds for httpx client timeout Returns: AirbyteClient: an instance of the `AirbyteClient` class \"\"\" self . airbyte_base_url = airbyte_base_url self . logger = logger self . timeout = timeout","title":"__init__()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.check_health_status","text":"Check the health status of an AirbyteInstance Parameters: Name Type Description Default client httpx . AsyncClient httpx.AsyncClient instance used to interact with the Airbyte API required Returns: Name Type Description bool representing whether the server is healthy Source code in prefect_airbyte/client.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 async def check_health_status ( self , client : httpx . AsyncClient ): \"\"\" Check the health status of an AirbyteInstance Args: client: `httpx.AsyncClient` instance used to interact with the Airbyte API Returns: bool: representing whether the server is healthy \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e )","title":"check_health_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.create_client","text":"Convenience method for establishing a healthy httpx Airbyte client Parameters: Name Type Description Default timeout int seconds for request timeout with this client required Returns: Type Description httpx . AsyncClient httpx.AsyncClient: client for interacting with Airbyte instance Source code in prefect_airbyte/client.py 87 88 89 90 91 92 93 94 95 96 97 async def create_client ( self ) -> httpx . AsyncClient : \"\"\" Convenience method for establishing a healthy `httpx` Airbyte client Args: timeout: `int` seconds for request timeout with this client Returns: httpx.AsyncClient: client for interacting with Airbyte instance \"\"\" client = await self . _establish_session () return client","title":"create_client()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.export_configuration","text":"Trigger an export of Airbyte configuration Parameters: Name Type Description Default client httpx client with which to make call to the Airbyte server required Returns: Type Description bytearray byte array of Airbyte configuration data Source code in prefect_airbyte/client.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 async def export_configuration ( self , ) -> bytearray : \"\"\" Trigger an export of Airbyte configuration Args: client: httpx client with which to make call to the Airbyte server Returns: byte array of Airbyte configuration data \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await client . post ( get_connection_url ) if response . status_code == 200 : self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : raise err . AirbyteExportConfigurationFailed ( e )","title":"export_configuration()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_connection_status","text":"Get the status of a defined Airbyte connection Parameters: Name Type Description Default connection_id str string value of the defined airbyte connection required Returns: Name Type Description str str the status of a defined Airbyte connection Source code in prefect_airbyte/client.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Get the status of a defined Airbyte connection Args: connection_id: string value of the defined airbyte connection Returns: str: the status of a defined Airbyte connection \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/get/\" # TODO - Missing auth because Airbyte API currently doesn't yet support auth try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException else : raise err . AirbyteServerNotHealthyException ( e )","title":"get_connection_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_job_status","text":"Get the status of an Airbyte connection sync job Parameters: Name Type Description Default job_id str str value of the airbyte job id as defined by airbyte required Returns: Type Description str byte array of Airbyte configuration data Source code in prefect_airbyte/client.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 async def get_job_status ( self , job_id : str ) -> str : \"\"\" Get the status of an Airbyte connection sync job Args: job_id: str value of the airbyte job id as defined by airbyte Returns: byte array of Airbyte configuration data \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await client . post ( get_connection_url , json = { \"id\" : job_id }) if response . status_code == 200 : job_status = response . json ()[ \"job\" ][ \"status\" ] job_created_at = response . json ()[ \"job\" ][ \"createdAt\" ] job_updated_at = response . json ()[ \"job\" ][ \"updatedAt\" ] return job_status , job_created_at , job_updated_at elif response . status_code == 404 : self . logger . error ( f \"Job { job_id } not found...\" ) raise err . JobNotFoundException ( f \"Job { job_id } not found...\" ) except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e )","title":"get_job_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.trigger_manual_sync_connection","text":"Trigger a manual sync of the Connection Parameters: Name Type Description Default connection_id str ID of connection to sync required Source code in prefect_airbyte/client.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Trigger a manual sync of the Connection Args: connection_id: ID of connection to sync Returns: created_at - timestamp of sync job creation \"\"\" client = await self . create_client () get_connection_url = self . airbyte_base_url + \"/connections/sync/\" # TODO - no current authentication methods from Airbyte try : response = await client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) if response . status_code == 200 : job_id = response . json ()[ \"job\" ][ \"id\" ] print ( response . json ()) job_created_at = response . json ()[ \"job\" ][ \"createdAt\" ] return job_id , job_created_at elif response . status_code == 404 : # connection_id not found self . logger . warning ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id ...\" ) raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id ...\" ) except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException ( e )","title":"trigger_manual_sync_connection()"},{"location":"configuration/","text":"prefect_airbyte.configuration Tasks for updating and fetching Airbyte configurations export_configuration async Task that exports an Airbyte config via {AIRBYTE_HOST}/api/v1/deployment/export Parameters: Name Type Description Default airbyte_server_host str Hostname of Airbyte server where connection is configured. Will overwrite the value provided at init if provided. 'localhost' airbyte_server_port str Port that the Airbyte server is listening on, will overwrite the value provided at init if provided. '8000' airbyte_api_version str Version of Airbyte API to use to trigger connection sync, will overwrite the value provided at init if provided. 'v1' timeout int timeout in seconds on the httpx AirbyteClient 5 Returns: Name Type Description bytearray bytearray bytearray containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere ( airbyte_configuration : bytearray somewhere : str = 'my_destination.gz' , ' ): with gzip . open ( 'my_destination.gz' , 'wb' ) as f : f . write ( airbyte_configuration ) @flow def example_export_configuration_flow (): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server_host = \"localhost\" , airbyte_server_port = \"8000\" , airbyte_api_version = \"v1\" , ) zip_and_write_somewhere ( airbyte_config = airbyte_config ) example_trigger_sync_flow () Source code in prefect_airbyte/configuration.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @task async def export_configuration ( airbyte_server_host : str = \"localhost\" , airbyte_server_port : int = \"8000\" , airbyte_api_version : str = \"v1\" , timeout : int = 5 , ) -> bytearray : \"\"\" Task that exports an Airbyte config via `{AIRBYTE_HOST}/api/v1/deployment/export` Args: airbyte_server_host (str, optional): Hostname of Airbyte server where connection is configured. Will overwrite the value provided at init if provided. airbyte_server_port (str, optional): Port that the Airbyte server is listening on, will overwrite the value provided at init if provided. airbyte_api_version (str, optional): Version of Airbyte API to use to trigger connection sync, will overwrite the value provided at init if provided. timeout (int): timeout in seconds on the httpx AirbyteClient Returns: bytearray: `bytearray` containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: ```python import gzip from prefect import flow, task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere( airbyte_configuration: bytearray somewhere: str = 'my_destination.gz',' ): with gzip.open('my_destination.gz', 'wb') as f: f.write(airbyte_configuration) @flow def example_export_configuration_flow(): # Run other tasks and subflows here airbyte_config = export_configuration( airbyte_server_host=\"localhost\", airbyte_server_port=\"8000\", airbyte_api_version=\"v1\", ) zip_and_write_somewhere(airbyte_config=airbyte_config) example_trigger_sync_flow() ``` \"\"\" logger = get_logger () airbyte_base_url = ( f \"http:// { airbyte_server_host } :\" f \" { airbyte_server_port } /api/ { airbyte_api_version } \" ) airbyte = AirbyteClient ( logger , airbyte_base_url , timeout = timeout ) logger . info ( \"Initiating export of Airbyte configuration\" ) airbyte_config = await airbyte . export_configuration () return airbyte_config","title":"Configuration"},{"location":"configuration/#prefect_airbyte.configuration","text":"Tasks for updating and fetching Airbyte configurations","title":"configuration"},{"location":"configuration/#prefect_airbyte.configuration.export_configuration","text":"Task that exports an Airbyte config via {AIRBYTE_HOST}/api/v1/deployment/export Parameters: Name Type Description Default airbyte_server_host str Hostname of Airbyte server where connection is configured. Will overwrite the value provided at init if provided. 'localhost' airbyte_server_port str Port that the Airbyte server is listening on, will overwrite the value provided at init if provided. '8000' airbyte_api_version str Version of Airbyte API to use to trigger connection sync, will overwrite the value provided at init if provided. 'v1' timeout int timeout in seconds on the httpx AirbyteClient 5 Returns: Name Type Description bytearray bytearray bytearray containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere ( airbyte_configuration : bytearray somewhere : str = 'my_destination.gz' , ' ): with gzip . open ( 'my_destination.gz' , 'wb' ) as f : f . write ( airbyte_configuration ) @flow def example_export_configuration_flow (): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server_host = \"localhost\" , airbyte_server_port = \"8000\" , airbyte_api_version = \"v1\" , ) zip_and_write_somewhere ( airbyte_config = airbyte_config ) example_trigger_sync_flow () Source code in prefect_airbyte/configuration.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @task async def export_configuration ( airbyte_server_host : str = \"localhost\" , airbyte_server_port : int = \"8000\" , airbyte_api_version : str = \"v1\" , timeout : int = 5 , ) -> bytearray : \"\"\" Task that exports an Airbyte config via `{AIRBYTE_HOST}/api/v1/deployment/export` Args: airbyte_server_host (str, optional): Hostname of Airbyte server where connection is configured. Will overwrite the value provided at init if provided. airbyte_server_port (str, optional): Port that the Airbyte server is listening on, will overwrite the value provided at init if provided. airbyte_api_version (str, optional): Version of Airbyte API to use to trigger connection sync, will overwrite the value provided at init if provided. timeout (int): timeout in seconds on the httpx AirbyteClient Returns: bytearray: `bytearray` containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: ```python import gzip from prefect import flow, task from prefect_airbyte.configuration import export_configuration @task def zip_and_write_somewhere( airbyte_configuration: bytearray somewhere: str = 'my_destination.gz',' ): with gzip.open('my_destination.gz', 'wb') as f: f.write(airbyte_configuration) @flow def example_export_configuration_flow(): # Run other tasks and subflows here airbyte_config = export_configuration( airbyte_server_host=\"localhost\", airbyte_server_port=\"8000\", airbyte_api_version=\"v1\", ) zip_and_write_somewhere(airbyte_config=airbyte_config) example_trigger_sync_flow() ``` \"\"\" logger = get_logger () airbyte_base_url = ( f \"http:// { airbyte_server_host } :\" f \" { airbyte_server_port } /api/ { airbyte_api_version } \" ) airbyte = AirbyteClient ( logger , airbyte_base_url , timeout = timeout ) logger . info ( \"Initiating export of Airbyte configuration\" ) airbyte_config = await airbyte . export_configuration () return airbyte_config","title":"export_configuration()"},{"location":"connections/","text":"prefect_airbyte.connections Tasks for connecting to Airbyte and triggering connection syncs trigger_sync async Task run method for triggering an Airbyte Connection. It is assumed that the user will have previously configured a Source & Destination into a Connection. e.g. MySql -> CSV An invocation of trigger_sync will attempt to start a sync job for the specified connection_id representing the Connection in Airbyte. trigger_sync will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. Parameters: Name Type Description Default str airbyte_server_host Hostname of Airbyte server where connection is configured. required str airbyte_server_port Port that the Airbyte server is listening on. required str airbyte_api_version Version of Airbyte API to use to trigger connection sync. required str connection_id the Airbyte connection ID required int poll_interval_s how often to poll the Airbyte API for sync status, if provided this will override the default polling time of 15 seconds. required bool status_updates whether to log status as the task polls jobs required str timeout The request timeout for the httpx.AsyncClient required Returns: Name Type Description dict dict connection_id (str) and succeeded_at (timestamp str) Examples: Flow that triggers an Airybte connection sync: from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( connection_id = \"your-connection-id-to-sync\" ) example_trigger_sync_flow () Source code in prefect_airbyte/connections.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @task async def trigger_sync ( airbyte_server_host : str = \"localhost\" , airbyte_server_port : int = \"8000\" , airbyte_api_version : str = \"v1\" , connection_id : str = None , poll_interval_s : int = 15 , status_updates : bool = False , timeout : int = 5 , ) -> dict : \"\"\" Task run method for triggering an Airbyte Connection. *It is assumed that the user will have previously configured a Source & Destination into a Connection.* e.g. MySql -> CSV An invocation of `trigger_sync` will attempt to start a sync job for the specified `connection_id` representing the Connection in Airbyte. `trigger_sync` will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. Args: str airbyte_server_host : Hostname of Airbyte server where connection is configured. str airbyte_server_port: Port that the Airbyte server is listening on. str airbyte_api_version: Version of Airbyte API to use to trigger connection sync. str connection_id: the Airbyte connection ID int poll_interval_s: how often to poll the Airbyte API for sync status, if provided this will override the default polling time of 15 seconds. bool status_updates: whether to log status as the task polls jobs str timeout: The request `timeout` for the `httpx.AsyncClient` Returns: dict: connection_id (str) and succeeded_at (timestamp str) Examples: Flow that triggers an Airybte connection sync: ```python from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow(): # Run other tasks and subflows here trigger_sync( connection_id=\"your-connection-id-to-sync\" ) example_trigger_sync_flow() ``` \"\"\" logger = get_logger () if not connection_id : raise ValueError ( \"Value for parameter `connection_id` *must* \\ be provided.\" ) try : uuid . UUID ( connection_id ) except ( TypeError , ValueError ): raise ValueError ( \"Parameter `connection_id` *must* be a valid UUID \\ i.e. 32 hex characters, including hyphens.\" ) # see https://airbyte-public-api-docs.s3.us-east-2.amazonaws.com # /rapidoc-api-docs.html#overview airbyte_base_url = ( f \"http:// { airbyte_server_host } :\" f \" { airbyte_server_port } /api/ { airbyte_api_version } \" ) airbyte = AirbyteClient ( logger , airbyte_base_url , timeout = timeout ) logger . info ( f \"Getting Airbyte Connection { connection_id } , poll interval \" f \" { poll_interval_s } seconds, airbyte_base_url { airbyte_base_url } \" ) connection_status = await airbyte . get_connection_status ( connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : # Trigger manual sync on the Connection ... job_id , job_created_at = await airbyte . trigger_manual_sync_connection ( connection_id ) job_status = JOB_STATUS_PENDING while job_status not in [ JOB_STATUS_FAILED , JOB_STATUS_SUCCEEDED ]: job_status , job_created_at , job_updated_at = await airbyte . get_job_status ( job_id ) # pending\u2503running\u2503incomplete\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : logger . info ( f \"Job { job_id } succeeded.\" ) elif job_status == JOB_STATUS_FAILED : logger . error ( f \"Job { job_id } failed.\" ) raise err . AirbyteSyncJobFailed ( f \"Job { job_id } failed.\" ) else : if status_updates : logger . info ( job_status ) # wait for next poll interval await sleep ( poll_interval_s ) return { \"connection_id\" : connection_id , \"status\" : connection_status , \"job_status\" : job_status , \"job_created_at\" : job_created_at , \"job_updated_at\" : job_updated_at , } elif connection_status == CONNECTION_STATUS_INACTIVE : logger . error ( f \"Connection: { connection_id } is inactive\" \" - you'll need to enable it in your Airbyte instance\" ) raise err . AirbyteConnectionInactiveException ( f \"Please enable the Connection { connection_id } in Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : logger . error ( f \"Connection { connection_id } is deprecated.\" ) raise err . AirbyeConnectionDeprecatedException ( f \"Connection { connection_id } is deprecated.\" )","title":"Connections"},{"location":"connections/#prefect_airbyte.connections","text":"Tasks for connecting to Airbyte and triggering connection syncs","title":"connections"},{"location":"connections/#prefect_airbyte.connections.trigger_sync","text":"Task run method for triggering an Airbyte Connection. It is assumed that the user will have previously configured a Source & Destination into a Connection. e.g. MySql -> CSV An invocation of trigger_sync will attempt to start a sync job for the specified connection_id representing the Connection in Airbyte. trigger_sync will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. Parameters: Name Type Description Default str airbyte_server_host Hostname of Airbyte server where connection is configured. required str airbyte_server_port Port that the Airbyte server is listening on. required str airbyte_api_version Version of Airbyte API to use to trigger connection sync. required str connection_id the Airbyte connection ID required int poll_interval_s how often to poll the Airbyte API for sync status, if provided this will override the default polling time of 15 seconds. required bool status_updates whether to log status as the task polls jobs required str timeout The request timeout for the httpx.AsyncClient required Returns: Name Type Description dict dict connection_id (str) and succeeded_at (timestamp str) Examples: Flow that triggers an Airybte connection sync: from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( connection_id = \"your-connection-id-to-sync\" ) example_trigger_sync_flow () Source code in prefect_airbyte/connections.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @task async def trigger_sync ( airbyte_server_host : str = \"localhost\" , airbyte_server_port : int = \"8000\" , airbyte_api_version : str = \"v1\" , connection_id : str = None , poll_interval_s : int = 15 , status_updates : bool = False , timeout : int = 5 , ) -> dict : \"\"\" Task run method for triggering an Airbyte Connection. *It is assumed that the user will have previously configured a Source & Destination into a Connection.* e.g. MySql -> CSV An invocation of `trigger_sync` will attempt to start a sync job for the specified `connection_id` representing the Connection in Airbyte. `trigger_sync` will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. Args: str airbyte_server_host : Hostname of Airbyte server where connection is configured. str airbyte_server_port: Port that the Airbyte server is listening on. str airbyte_api_version: Version of Airbyte API to use to trigger connection sync. str connection_id: the Airbyte connection ID int poll_interval_s: how often to poll the Airbyte API for sync status, if provided this will override the default polling time of 15 seconds. bool status_updates: whether to log status as the task polls jobs str timeout: The request `timeout` for the `httpx.AsyncClient` Returns: dict: connection_id (str) and succeeded_at (timestamp str) Examples: Flow that triggers an Airybte connection sync: ```python from prefect import flow from prefect_airbyte.connections import trigger_sync @flow def example_trigger_sync_flow(): # Run other tasks and subflows here trigger_sync( connection_id=\"your-connection-id-to-sync\" ) example_trigger_sync_flow() ``` \"\"\" logger = get_logger () if not connection_id : raise ValueError ( \"Value for parameter `connection_id` *must* \\ be provided.\" ) try : uuid . UUID ( connection_id ) except ( TypeError , ValueError ): raise ValueError ( \"Parameter `connection_id` *must* be a valid UUID \\ i.e. 32 hex characters, including hyphens.\" ) # see https://airbyte-public-api-docs.s3.us-east-2.amazonaws.com # /rapidoc-api-docs.html#overview airbyte_base_url = ( f \"http:// { airbyte_server_host } :\" f \" { airbyte_server_port } /api/ { airbyte_api_version } \" ) airbyte = AirbyteClient ( logger , airbyte_base_url , timeout = timeout ) logger . info ( f \"Getting Airbyte Connection { connection_id } , poll interval \" f \" { poll_interval_s } seconds, airbyte_base_url { airbyte_base_url } \" ) connection_status = await airbyte . get_connection_status ( connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : # Trigger manual sync on the Connection ... job_id , job_created_at = await airbyte . trigger_manual_sync_connection ( connection_id ) job_status = JOB_STATUS_PENDING while job_status not in [ JOB_STATUS_FAILED , JOB_STATUS_SUCCEEDED ]: job_status , job_created_at , job_updated_at = await airbyte . get_job_status ( job_id ) # pending\u2503running\u2503incomplete\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : logger . info ( f \"Job { job_id } succeeded.\" ) elif job_status == JOB_STATUS_FAILED : logger . error ( f \"Job { job_id } failed.\" ) raise err . AirbyteSyncJobFailed ( f \"Job { job_id } failed.\" ) else : if status_updates : logger . info ( job_status ) # wait for next poll interval await sleep ( poll_interval_s ) return { \"connection_id\" : connection_id , \"status\" : connection_status , \"job_status\" : job_status , \"job_created_at\" : job_created_at , \"job_updated_at\" : job_updated_at , } elif connection_status == CONNECTION_STATUS_INACTIVE : logger . error ( f \"Connection: { connection_id } is inactive\" \" - you'll need to enable it in your Airbyte instance\" ) raise err . AirbyteConnectionInactiveException ( f \"Please enable the Connection { connection_id } in Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : logger . error ( f \"Connection { connection_id } is deprecated.\" ) raise err . AirbyeConnectionDeprecatedException ( f \"Connection { connection_id } is deprecated.\" )","title":"trigger_sync()"}]}