{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"prefect-airbyte Welcome! prefect-airbyte is a collection of prebuilt Prefect tasks and flows that can be used to quickly construct Prefect flows to interact with Airbyte . Getting Started Python setup Requires an installation of Python 3.7+ We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation . Airbyte setup See the airbyte documention on how to get your own instance. Installation Install prefect-airbyte pip install prefect-airbyte A list of available blocks in prefect-airbyte and their setup instructions can be found here . Examples Create an AirbyteServer block and save it from prefect_airbyte.server import AirbyteServer # running airbyte locally at http://localhost:8000 with default auth local_airbyte_server = AirbyteServer () # running airbyte remotely at http://<someIP>:<somePort> as user `Marvin` remote_airbyte_server = AirbyteServer ( username = \"Marvin\" , password = \"DontPanic42\" , server_host = \"42.42.42.42\" , server_port = \"4242\" ) local_airbyte_server . save ( \"my-local-airbyte-server\" ) remote_airbyte_server . save ( \"my-remote-airbyte-server\" ) Trigger a defined connection sync from prefect import flow from prefect_airbyte.server import AirbyteServer from prefect_airbyte.connections import AirbyteConnection from prefect_airbyte.flows import run_connection_sync server = AirbyteServer ( server_host = \"localhost\" , server_port = 8000 ) connection = AirbyteConnection ( airbyte_server = server , connection_id = \"e1b2078f-882a-4f50-9942-cfe34b2d825b\" , status_updates = True , ) @flow def airbyte_syncs (): # do some setup sync_result = run_connection_sync ( airbyte_connection = connection , ) # do some other things, like trigger DBT based on number of records synced print ( f 'Number of Records Synced: { sync_result . records_synced } ' ) \u276f python airbyte_syncs.py 03:46:03 | prefect.engine - Created flow run 'thick-seahorse' for flow 'example_trigger_sync_flow' 03:46:03 | Flow run 'thick-seahorse' - Using task runner 'ConcurrentTaskRunner' 03:46:03 | Flow run 'thick-seahorse' - Created task run 'trigger_sync-35f0e9c2-0' for task 'trigger_sync' 03:46:03 | prefect - trigger airbyte connection: e1b2078f-882a-4f50-9942-cfe34b2d825b, poll interval 3 seconds 03:46:03 | prefect - pending 03:46:06 | prefect - running 03:46:09 | prefect - running 03:46:12 | prefect - running 03:46:16 | prefect - running 03:46:19 | prefect - running 03:46:22 | prefect - Job 26 succeeded. 03:46:22 | Task run 'trigger_sync-35f0e9c2-0' - Finished in state Completed(None) 03:46:22 | Flow run 'thick-seahorse' - Finished in state Completed('All states completed.') Export an Airbyte instance's configuration NOTE : The API endpoint corresponding to this task is no longer supported by open-source Airbyte versions as of v0.40.7. Check out the Octavia CLI docs for more info. import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere ( airbyte_config : bytearray , somewhere : str , ): with gzip . open ( somewhere , 'wb' ) as f : f . write ( airbyte_config ) @flow def example_export_configuration_flow ( filepath : str ): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server = AirbyteServer . load ( \"my-airbyte-server-block\" ) ) zip_and_write_somewhere ( somewhere = filepath , airbyte_config = airbyte_config ) if __name__ == \"__main__\" : example_export_configuration_flow ( '*://**/my_destination.gz' ) Use with_options to customize options on any existing task or flow from prefect import flow from prefect_airbyte.connections import AirbyteConnection from prefect_airbyte.flows import run_connection_sync custom_run_connection_sync = run_connection_sync . with_options ( name = \"Custom Airbyte Sync Flow\" , retries = 2 , retry_delay_seconds = 10 , ) @flow def some_airbyte_flow (): custom_run_connection_sync ( airbyte_connection = AirbyteConnection . load ( \"my-airbyte-connection-block\" ) ) some_airbyte_flow () For more tips on how to use tasks and flows in a Collection, check out Using Collections ! Blocks Catalog Below is a list of Blocks available for registration in prefect-airbyte . To register blocks in this module to view and edit them on Prefect Cloud: prefect block register -m prefect_airbyte Note, to use the load method on Blocks, you must already have a block document saved through code or saved through the UI . Server Module AirbyteServer To load the AirbyteServer: from prefect import flow from prefect_airbyte.server import AirbyteServer @flow def my_flow (): my_block = AirbyteServer . load ( \"MY_BLOCK_NAME\" ) my_flow () Connections Module AirbyteConnection To load the AirbyteConnection: from prefect import flow from prefect_airbyte.connections import AirbyteConnection @flow def my_flow (): my_block = AirbyteConnection . load ( \"MY_BLOCK_NAME\" ) my_flow () Resources If you encounter and bugs while using prefect-airbyte , feel free to open an issue in the prefect-airbyte repository. If you have any questions or issues while using prefect-airbyte , you can find help in either the Prefect Discourse forum or the Prefect Slack community Feel free to star or watch prefect-airbyte for updates too! Contribute If you'd like to help contribute to fix an issue or add a feature to prefect-airbyte , please propose changes through a pull request from a fork of the repository . Contribution Steps: Fork the repository Clone the forked repository Install the repository and its dependencies: pip install -e \".[dev]\" Make desired changes. Add tests. Insert an entry to CHANGELOG.md Install pre-commit to perform quality checks prior to commit: pre-commit install git commit , git push , and create a pull request.","title":"Home"},{"location":"#prefect-airbyte","text":"","title":"prefect-airbyte"},{"location":"#welcome","text":"prefect-airbyte is a collection of prebuilt Prefect tasks and flows that can be used to quickly construct Prefect flows to interact with Airbyte .","title":"Welcome!"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#python-setup","text":"Requires an installation of Python 3.7+ We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation .","title":"Python setup"},{"location":"#airbyte-setup","text":"See the airbyte documention on how to get your own instance.","title":"Airbyte setup"},{"location":"#installation","text":"Install prefect-airbyte pip install prefect-airbyte A list of available blocks in prefect-airbyte and their setup instructions can be found here .","title":"Installation"},{"location":"#examples","text":"","title":"Examples"},{"location":"#create-an-airbyteserver-block-and-save-it","text":"from prefect_airbyte.server import AirbyteServer # running airbyte locally at http://localhost:8000 with default auth local_airbyte_server = AirbyteServer () # running airbyte remotely at http://<someIP>:<somePort> as user `Marvin` remote_airbyte_server = AirbyteServer ( username = \"Marvin\" , password = \"DontPanic42\" , server_host = \"42.42.42.42\" , server_port = \"4242\" ) local_airbyte_server . save ( \"my-local-airbyte-server\" ) remote_airbyte_server . save ( \"my-remote-airbyte-server\" )","title":"Create an AirbyteServer block and save it"},{"location":"#trigger-a-defined-connection-sync","text":"from prefect import flow from prefect_airbyte.server import AirbyteServer from prefect_airbyte.connections import AirbyteConnection from prefect_airbyte.flows import run_connection_sync server = AirbyteServer ( server_host = \"localhost\" , server_port = 8000 ) connection = AirbyteConnection ( airbyte_server = server , connection_id = \"e1b2078f-882a-4f50-9942-cfe34b2d825b\" , status_updates = True , ) @flow def airbyte_syncs (): # do some setup sync_result = run_connection_sync ( airbyte_connection = connection , ) # do some other things, like trigger DBT based on number of records synced print ( f 'Number of Records Synced: { sync_result . records_synced } ' ) \u276f python airbyte_syncs.py 03:46:03 | prefect.engine - Created flow run 'thick-seahorse' for flow 'example_trigger_sync_flow' 03:46:03 | Flow run 'thick-seahorse' - Using task runner 'ConcurrentTaskRunner' 03:46:03 | Flow run 'thick-seahorse' - Created task run 'trigger_sync-35f0e9c2-0' for task 'trigger_sync' 03:46:03 | prefect - trigger airbyte connection: e1b2078f-882a-4f50-9942-cfe34b2d825b, poll interval 3 seconds 03:46:03 | prefect - pending 03:46:06 | prefect - running 03:46:09 | prefect - running 03:46:12 | prefect - running 03:46:16 | prefect - running 03:46:19 | prefect - running 03:46:22 | prefect - Job 26 succeeded. 03:46:22 | Task run 'trigger_sync-35f0e9c2-0' - Finished in state Completed(None) 03:46:22 | Flow run 'thick-seahorse' - Finished in state Completed('All states completed.')","title":"Trigger a defined connection sync"},{"location":"#export-an-airbyte-instances-configuration","text":"NOTE : The API endpoint corresponding to this task is no longer supported by open-source Airbyte versions as of v0.40.7. Check out the Octavia CLI docs for more info. import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere ( airbyte_config : bytearray , somewhere : str , ): with gzip . open ( somewhere , 'wb' ) as f : f . write ( airbyte_config ) @flow def example_export_configuration_flow ( filepath : str ): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server = AirbyteServer . load ( \"my-airbyte-server-block\" ) ) zip_and_write_somewhere ( somewhere = filepath , airbyte_config = airbyte_config ) if __name__ == \"__main__\" : example_export_configuration_flow ( '*://**/my_destination.gz' )","title":"Export an Airbyte instance's configuration"},{"location":"#use-with_options-to-customize-options-on-any-existing-task-or-flow","text":"from prefect import flow from prefect_airbyte.connections import AirbyteConnection from prefect_airbyte.flows import run_connection_sync custom_run_connection_sync = run_connection_sync . with_options ( name = \"Custom Airbyte Sync Flow\" , retries = 2 , retry_delay_seconds = 10 , ) @flow def some_airbyte_flow (): custom_run_connection_sync ( airbyte_connection = AirbyteConnection . load ( \"my-airbyte-connection-block\" ) ) some_airbyte_flow () For more tips on how to use tasks and flows in a Collection, check out Using Collections !","title":"Use with_options to customize options on any existing task or flow"},{"location":"#blocks-catalog","text":"Below is a list of Blocks available for registration in prefect-airbyte . To register blocks in this module to view and edit them on Prefect Cloud: prefect block register -m prefect_airbyte Note, to use the load method on Blocks, you must already have a block document saved through code or saved through the UI .","title":"Blocks Catalog"},{"location":"#server-module","text":"AirbyteServer To load the AirbyteServer: from prefect import flow from prefect_airbyte.server import AirbyteServer @flow def my_flow (): my_block = AirbyteServer . load ( \"MY_BLOCK_NAME\" ) my_flow ()","title":"Server Module"},{"location":"#connections-module","text":"AirbyteConnection To load the AirbyteConnection: from prefect import flow from prefect_airbyte.connections import AirbyteConnection @flow def my_flow (): my_block = AirbyteConnection . load ( \"MY_BLOCK_NAME\" ) my_flow ()","title":"Connections Module"},{"location":"#resources","text":"If you encounter and bugs while using prefect-airbyte , feel free to open an issue in the prefect-airbyte repository. If you have any questions or issues while using prefect-airbyte , you can find help in either the Prefect Discourse forum or the Prefect Slack community Feel free to star or watch prefect-airbyte for updates too!","title":"Resources"},{"location":"#contribute","text":"If you'd like to help contribute to fix an issue or add a feature to prefect-airbyte , please propose changes through a pull request from a fork of the repository .","title":"Contribute"},{"location":"#contribution-steps","text":"Fork the repository Clone the forked repository Install the repository and its dependencies: pip install -e \".[dev]\" Make desired changes. Add tests. Insert an entry to CHANGELOG.md Install pre-commit to perform quality checks prior to commit: pre-commit install git commit , git push , and create a pull request.","title":"Contribution Steps:"},{"location":"client/","text":"prefect_airbyte.client Client for interacting with Airbyte instance Classes AirbyteClient Client class used to call API endpoints on an Airbyte server. This client currently supports username/password authentication as set in auth . For more info, see the Airbyte docs . Attributes: Name Type Description airbyte_base_url str Base API endpoint URL for Airbyte. auth Username and password for Airbyte API. logger A logger instance used by the client to log messages related to API calls. timeout The number of seconds to wait before an API call times out. Source code in prefect_airbyte/client.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 class AirbyteClient : \"\"\" Client class used to call API endpoints on an Airbyte server. This client currently supports username/password authentication as set in `auth`. For more info, see the [Airbyte docs](https://docs.airbyte.io/api-documentation). Attributes: airbyte_base_url str: Base API endpoint URL for Airbyte. auth: Username and password for Airbyte API. logger: A logger instance used by the client to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. \"\"\" def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , auth : Tuple [ str , str ] = ( \"airbyte\" , \"password\" ), timeout : int = 5 , ): self . _closed = False self . _started = False self . airbyte_base_url = airbyte_base_url self . auth = auth self . logger = logger self . timeout = timeout self . _client = httpx . AsyncClient ( base_url = self . airbyte_base_url , auth = self . auth , timeout = self . timeout ) async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an Airbyte instance. Args: client: `httpx.AsyncClient` used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. **Note**: As of Airbyte v0.40.7-alpha, this endpoint no longer exists. Returns: Gzipped Airbyte configuration data. \"\"\" warn ( \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \" \"exporting configurations. See the Octavia CLI docs for more info.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await self . _client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : if e . response . status_code == 404 : self . logger . error ( \"If you are using Airbyte v0.40.7-alpha, there is no longer \" \"an API endpoint for exporting configurations.\" ) raise err . AirbyteExportConfigurationFailed () from e async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/sync/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def get_job_status ( self , job_id : str ) -> Tuple [ str , int , int ]: \"\"\" Gets the status of an Airbyte connection sync job. **Note**: Deprecated in favor of `AirbyteClient.get_job_info`. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" warn ( \"`AirbyteClient.get_job_status` is deprecated and will be removed in \" \"a future release. If you are using this client method directly, please \" \"use the `AirbyteClient.get_job_info` method instead. If you are\" \"seeing this warning while using the `trigger_sync` task, please \" \"define an `AirbyteConnection` and use `run_connection_sync` instead.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def get_job_info ( self , job_id : str ) -> Dict [ str , Any ]: \"\"\" Gets the full API response for a given Airbyte Job ID. Args: job_id: The ID of the Airbyte job to retrieve information on. Returns: Dict of the full API response for the given job ID. \"\"\" get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () return response . json () except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def create_client ( self ) -> httpx . AsyncClient : \"\"\"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire `AirbyteClient` class as a context manager. \"\"\" warn ( \"Use of this method will be removed in a future release - \" \"please use the `AirbyteClient` class as a context manager.\" , DeprecationWarning , stacklevel = 2 , ) return self . _client async def __aenter__ ( self ): \"\"\"Context manager entry point.\"\"\" if self . _closed : raise RuntimeError ( \"The client cannot be started again after it has been closed.\" ) if self . _started : raise RuntimeError ( \"The client cannot be started more than once.\" ) self . _started = True await self . check_health_status ( self . _client ) return self async def __aexit__ ( self , * exc ): \"\"\"Context manager exit point.\"\"\" self . _closed = True await self . _client . __aexit__ () Functions __aenter__ async Context manager entry point. Source code in prefect_airbyte/client.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 async def __aenter__ ( self ): \"\"\"Context manager entry point.\"\"\" if self . _closed : raise RuntimeError ( \"The client cannot be started again after it has been closed.\" ) if self . _started : raise RuntimeError ( \"The client cannot be started more than once.\" ) self . _started = True await self . check_health_status ( self . _client ) return self __aexit__ async Context manager exit point. Source code in prefect_airbyte/client.py 258 259 260 261 262 async def __aexit__ ( self , * exc ): \"\"\"Context manager exit point.\"\"\" self . _closed = True await self . _client . __aexit__ () check_health_status async Checks the health status of an Airbyte instance. Parameters: Name Type Description Default client httpx . AsyncClient httpx.AsyncClient used to interact with the Airbyte API. required Returns: Type Description bool True if the server is healthy. False otherwise. Source code in prefect_airbyte/client.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an Airbyte instance. Args: client: `httpx.AsyncClient` used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e create_client async Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire AirbyteClient class as a context manager. Source code in prefect_airbyte/client.py 229 230 231 232 233 234 235 236 237 238 239 240 241 async def create_client ( self ) -> httpx . AsyncClient : \"\"\"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire `AirbyteClient` class as a context manager. \"\"\" warn ( \"Use of this method will be removed in a future release - \" \"please use the `AirbyteClient` class as a context manager.\" , DeprecationWarning , stacklevel = 2 , ) return self . _client export_configuration async Triggers an export of Airbyte configuration. Note : As of Airbyte v0.40.7-alpha, this endpoint no longer exists. Returns: Type Description bytes Gzipped Airbyte configuration data. Source code in prefect_airbyte/client.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. **Note**: As of Airbyte v0.40.7-alpha, this endpoint no longer exists. Returns: Gzipped Airbyte configuration data. \"\"\" warn ( \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \" \"exporting configurations. See the Octavia CLI docs for more info.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await self . _client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : if e . response . status_code == 404 : self . logger . error ( \"If you are using Airbyte v0.40.7-alpha, there is no longer \" \"an API endpoint for exporting configurations.\" ) raise err . AirbyteExportConfigurationFailed () from e get_connection_status async Gets the status of a defined Airbyte connection. Parameters: Name Type Description Default connection_id str ID of an existing Airbyte connection. required Returns: Type Description str The status of the defined Airbyte connection. Source code in prefect_airbyte/client.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e get_job_info async Gets the full API response for a given Airbyte Job ID. Parameters: Name Type Description Default job_id str The ID of the Airbyte job to retrieve information on. required Returns: Type Description Dict [ str , Any ] Dict of the full API response for the given job ID. Source code in prefect_airbyte/client.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 async def get_job_info ( self , job_id : str ) -> Dict [ str , Any ]: \"\"\" Gets the full API response for a given Airbyte Job ID. Args: job_id: The ID of the Airbyte job to retrieve information on. Returns: Dict of the full API response for the given job ID. \"\"\" get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () return response . json () except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e get_job_status async Gets the status of an Airbyte connection sync job. Note : Deprecated in favor of AirbyteClient.get_job_info . Parameters: Name Type Description Default job_id str ID of the Airbyte job to check. required Returns: Name Type Description job_status str The current status of the job. job_created_at int Datetime string of when the job was created. job_updated_at int Datetime string of the when the job was last updated. Source code in prefect_airbyte/client.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 async def get_job_status ( self , job_id : str ) -> Tuple [ str , int , int ]: \"\"\" Gets the status of an Airbyte connection sync job. **Note**: Deprecated in favor of `AirbyteClient.get_job_info`. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" warn ( \"`AirbyteClient.get_job_status` is deprecated and will be removed in \" \"a future release. If you are using this client method directly, please \" \"use the `AirbyteClient.get_job_info` method instead. If you are\" \"seeing this warning while using the `trigger_sync` task, please \" \"define an `AirbyteConnection` and use `run_connection_sync` instead.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e trigger_manual_sync_connection async Triggers a manual sync of the connection. Parameters: Name Type Description Default connection_id str ID of connection to sync. required Returns: Name Type Description job_id str ID of the job that was triggered. created_at str Datetime string of when the job was created. Source code in prefect_airbyte/client.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/sync/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"Client"},{"location":"client/#prefect_airbyte.client","text":"Client for interacting with Airbyte instance","title":"client"},{"location":"client/#prefect_airbyte.client-classes","text":"","title":"Classes"},{"location":"client/#prefect_airbyte.client.AirbyteClient","text":"Client class used to call API endpoints on an Airbyte server. This client currently supports username/password authentication as set in auth . For more info, see the Airbyte docs . Attributes: Name Type Description airbyte_base_url str Base API endpoint URL for Airbyte. auth Username and password for Airbyte API. logger A logger instance used by the client to log messages related to API calls. timeout The number of seconds to wait before an API call times out. Source code in prefect_airbyte/client.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 class AirbyteClient : \"\"\" Client class used to call API endpoints on an Airbyte server. This client currently supports username/password authentication as set in `auth`. For more info, see the [Airbyte docs](https://docs.airbyte.io/api-documentation). Attributes: airbyte_base_url str: Base API endpoint URL for Airbyte. auth: Username and password for Airbyte API. logger: A logger instance used by the client to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. \"\"\" def __init__ ( self , logger : logging . Logger , airbyte_base_url : str = \"http://localhost:8000/api/v1\" , auth : Tuple [ str , str ] = ( \"airbyte\" , \"password\" ), timeout : int = 5 , ): self . _closed = False self . _started = False self . airbyte_base_url = airbyte_base_url self . auth = auth self . logger = logger self . timeout = timeout self . _client = httpx . AsyncClient ( base_url = self . airbyte_base_url , auth = self . auth , timeout = self . timeout ) async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an Airbyte instance. Args: client: `httpx.AsyncClient` used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. **Note**: As of Airbyte v0.40.7-alpha, this endpoint no longer exists. Returns: Gzipped Airbyte configuration data. \"\"\" warn ( \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \" \"exporting configurations. See the Octavia CLI docs for more info.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await self . _client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : if e . response . status_code == 404 : self . logger . error ( \"If you are using Airbyte v0.40.7-alpha, there is no longer \" \"an API endpoint for exporting configurations.\" ) raise err . AirbyteExportConfigurationFailed () from e async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/sync/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def get_job_status ( self , job_id : str ) -> Tuple [ str , int , int ]: \"\"\" Gets the status of an Airbyte connection sync job. **Note**: Deprecated in favor of `AirbyteClient.get_job_info`. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" warn ( \"`AirbyteClient.get_job_status` is deprecated and will be removed in \" \"a future release. If you are using this client method directly, please \" \"use the `AirbyteClient.get_job_info` method instead. If you are\" \"seeing this warning while using the `trigger_sync` task, please \" \"define an `AirbyteConnection` and use `run_connection_sync` instead.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def get_job_info ( self , job_id : str ) -> Dict [ str , Any ]: \"\"\" Gets the full API response for a given Airbyte Job ID. Args: job_id: The ID of the Airbyte job to retrieve information on. Returns: Dict of the full API response for the given job ID. \"\"\" get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () return response . json () except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e async def create_client ( self ) -> httpx . AsyncClient : \"\"\"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire `AirbyteClient` class as a context manager. \"\"\" warn ( \"Use of this method will be removed in a future release - \" \"please use the `AirbyteClient` class as a context manager.\" , DeprecationWarning , stacklevel = 2 , ) return self . _client async def __aenter__ ( self ): \"\"\"Context manager entry point.\"\"\" if self . _closed : raise RuntimeError ( \"The client cannot be started again after it has been closed.\" ) if self . _started : raise RuntimeError ( \"The client cannot be started more than once.\" ) self . _started = True await self . check_health_status ( self . _client ) return self async def __aexit__ ( self , * exc ): \"\"\"Context manager exit point.\"\"\" self . _closed = True await self . _client . __aexit__ ()","title":"AirbyteClient"},{"location":"client/#prefect_airbyte.client.AirbyteClient-functions","text":"","title":"Functions"},{"location":"client/#prefect_airbyte.client.AirbyteClient.__aenter__","text":"Context manager entry point. Source code in prefect_airbyte/client.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 async def __aenter__ ( self ): \"\"\"Context manager entry point.\"\"\" if self . _closed : raise RuntimeError ( \"The client cannot be started again after it has been closed.\" ) if self . _started : raise RuntimeError ( \"The client cannot be started more than once.\" ) self . _started = True await self . check_health_status ( self . _client ) return self","title":"__aenter__()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.__aexit__","text":"Context manager exit point. Source code in prefect_airbyte/client.py 258 259 260 261 262 async def __aexit__ ( self , * exc ): \"\"\"Context manager exit point.\"\"\" self . _closed = True await self . _client . __aexit__ ()","title":"__aexit__()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.check_health_status","text":"Checks the health status of an Airbyte instance. Parameters: Name Type Description Default client httpx . AsyncClient httpx.AsyncClient used to interact with the Airbyte API. required Returns: Type Description bool True if the server is healthy. False otherwise. Source code in prefect_airbyte/client.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 async def check_health_status ( self , client : httpx . AsyncClient ) -> bool : \"\"\" Checks the health status of an Airbyte instance. Args: client: `httpx.AsyncClient` used to interact with the Airbyte API. Returns: True if the server is healthy. False otherwise. \"\"\" get_connection_url = self . airbyte_base_url + \"/health/\" try : response = await client . get ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Health check response: %s \" , response . json ()) key = \"available\" if \"available\" in response . json () else \"db\" health_status = response . json ()[ key ] if not health_status : raise err . AirbyteServerNotHealthyException ( f \"Airbyte Server health status: { health_status } \" ) return True except httpx . HTTPStatusError as e : raise err . AirbyteServerNotHealthyException () from e","title":"check_health_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.create_client","text":"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire AirbyteClient class as a context manager. Source code in prefect_airbyte/client.py 229 230 231 232 233 234 235 236 237 238 239 240 241 async def create_client ( self ) -> httpx . AsyncClient : \"\"\"Convencience method to create a new httpx.AsyncClient. To be removed in favor of using the entire `AirbyteClient` class as a context manager. \"\"\" warn ( \"Use of this method will be removed in a future release - \" \"please use the `AirbyteClient` class as a context manager.\" , DeprecationWarning , stacklevel = 2 , ) return self . _client","title":"create_client()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.export_configuration","text":"Triggers an export of Airbyte configuration. Note : As of Airbyte v0.40.7-alpha, this endpoint no longer exists. Returns: Type Description bytes Gzipped Airbyte configuration data. Source code in prefect_airbyte/client.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 async def export_configuration ( self , ) -> bytes : \"\"\" Triggers an export of Airbyte configuration. **Note**: As of Airbyte v0.40.7-alpha, this endpoint no longer exists. Returns: Gzipped Airbyte configuration data. \"\"\" warn ( \"As of Airbyte v0.40.7-alpha, the Airbyte API no longer supports \" \"exporting configurations. See the Octavia CLI docs for more info.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/deployment/export/\" try : response = await self . _client . post ( get_connection_url ) response . raise_for_status () self . logger . debug ( \"Export configuration response: %s \" , response ) export_config = response . content return export_config except httpx . HTTPStatusError as e : if e . response . status_code == 404 : self . logger . error ( \"If you are using Airbyte v0.40.7-alpha, there is no longer \" \"an API endpoint for exporting configurations.\" ) raise err . AirbyteExportConfigurationFailed () from e","title":"export_configuration()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_connection_status","text":"Gets the status of a defined Airbyte connection. Parameters: Name Type Description Default connection_id str ID of an existing Airbyte connection. required Returns: Type Description str The status of the defined Airbyte connection. Source code in prefect_airbyte/client.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 async def get_connection_status ( self , connection_id : str ) -> str : \"\"\" Gets the status of a defined Airbyte connection. Args: connection_id: ID of an existing Airbyte connection. Returns: The status of the defined Airbyte connection. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () connection_status = response . json ()[ \"status\" ] return connection_status except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException () from e else : raise err . AirbyteServerNotHealthyException () from e","title":"get_connection_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_job_info","text":"Gets the full API response for a given Airbyte Job ID. Parameters: Name Type Description Default job_id str The ID of the Airbyte job to retrieve information on. required Returns: Type Description Dict [ str , Any ] Dict of the full API response for the given job ID. Source code in prefect_airbyte/client.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 async def get_job_info ( self , job_id : str ) -> Dict [ str , Any ]: \"\"\" Gets the full API response for a given Airbyte Job ID. Args: job_id: The ID of the Airbyte job to retrieve information on. Returns: Dict of the full API response for the given job ID. \"\"\" get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () return response . json () except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"get_job_info()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.get_job_status","text":"Gets the status of an Airbyte connection sync job. Note : Deprecated in favor of AirbyteClient.get_job_info . Parameters: Name Type Description Default job_id str ID of the Airbyte job to check. required Returns: Name Type Description job_status str The current status of the job. job_created_at int Datetime string of when the job was created. job_updated_at int Datetime string of the when the job was last updated. Source code in prefect_airbyte/client.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 async def get_job_status ( self , job_id : str ) -> Tuple [ str , int , int ]: \"\"\" Gets the status of an Airbyte connection sync job. **Note**: Deprecated in favor of `AirbyteClient.get_job_info`. Args: job_id: ID of the Airbyte job to check. Returns: job_status: The current status of the job. job_created_at: Datetime string of when the job was created. job_updated_at: Datetime string of the when the job was last updated. \"\"\" warn ( \"`AirbyteClient.get_job_status` is deprecated and will be removed in \" \"a future release. If you are using this client method directly, please \" \"use the `AirbyteClient.get_job_info` method instead. If you are\" \"seeing this warning while using the `trigger_sync` task, please \" \"define an `AirbyteConnection` and use `run_connection_sync` instead.\" , DeprecationWarning , stacklevel = 2 , ) get_connection_url = self . airbyte_base_url + \"/jobs/get/\" try : response = await self . _client . post ( get_connection_url , json = { \"id\" : job_id }) response . raise_for_status () job = response . json ()[ \"job\" ] job_status = job [ \"status\" ] job_created_at = job [ \"createdAt\" ] job_updated_at = job [ \"updatedAt\" ] return job_status , job_created_at , job_updated_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . JobNotFoundException ( f \"Job { job_id } not found.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"get_job_status()"},{"location":"client/#prefect_airbyte.client.AirbyteClient.trigger_manual_sync_connection","text":"Triggers a manual sync of the connection. Parameters: Name Type Description Default connection_id str ID of connection to sync. required Returns: Name Type Description job_id str ID of the job that was triggered. created_at str Datetime string of when the job was created. Source code in prefect_airbyte/client.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 async def trigger_manual_sync_connection ( self , connection_id : str ) -> Tuple [ str , str ]: \"\"\" Triggers a manual sync of the connection. Args: connection_id: ID of connection to sync. Returns: job_id: ID of the job that was triggered. created_at: Datetime string of when the job was created. \"\"\" get_connection_url = self . airbyte_base_url + \"/connections/sync/\" try : response = await self . _client . post ( get_connection_url , json = { \"connectionId\" : connection_id } ) response . raise_for_status () job = response . json ()[ \"job\" ] job_id = job [ \"id\" ] job_created_at = job [ \"createdAt\" ] return job_id , job_created_at except httpx . HTTPStatusError as e : if e . response . status_code == 404 : raise err . ConnectionNotFoundException ( f \"Connection { connection_id } not found, please double \" f \"check the connection_id.\" ) from e raise err . AirbyteServerNotHealthyException () from e","title":"trigger_manual_sync_connection()"},{"location":"configuration/","text":"prefect_airbyte.configuration Tasks for updating and fetching Airbyte configurations Classes Functions export_configuration async Prefect Task that exports an Airbyte configuration via {airbyte_server_host}/api/v1/deployment/export . As of prefect-airbyte==0.1.3 , the kwargs airbyte_server_host and airbyte_server_port can be replaced by passing an airbyte_server block instance to generate the AirbyteClient . Using the airbyte_server block is preferred, but the individual kwargs remain for backwards compatibility. Parameters: Name Type Description Default airbyte_server Optional [ AirbyteServer ] An AirbyteServer block for generating an AirbyteClient . None airbyte_server_host Optional [ str ] Airbyte server host to connect to. None airbyte_server_port Optional [ int ] Airbyte server port to connect to. None airbyte_api_version Optional [ str ] Airbyte API version to use. None timeout int Timeout in seconds on the httpx.AsyncClient . 5 Returns: Type Description bytes Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere ( airbyte_configuration : bytes somewhere : str = 'my_destination.gz' , ' ): with gzip . open ( 'my_destination.gz' , 'wb' ) as f : f . write ( airbyte_configuration ) @flow def example_export_configuration_flow (): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server = AirbyteServer . load ( \"oss-airbyte\" ) ) zip_and_write_somewhere ( airbyte_config = airbyte_config ) example_trigger_sync_flow () Source code in prefect_airbyte/configuration.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @task async def export_configuration ( airbyte_server : Optional [ AirbyteServer ] = None , airbyte_server_host : Optional [ str ] = None , airbyte_server_port : Optional [ int ] = None , airbyte_api_version : Optional [ str ] = None , timeout : int = 5 , ) -> bytes : \"\"\" Prefect Task that exports an Airbyte configuration via `{airbyte_server_host}/api/v1/deployment/export`. As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and `airbyte_server_port` can be replaced by passing an `airbyte_server` block instance to generate the `AirbyteClient`. Using the `airbyte_server` block is preferred, but the individual kwargs remain for backwards compatibility. Args: airbyte_server: An `AirbyteServer` block for generating an `AirbyteClient`. airbyte_server_host: Airbyte server host to connect to. airbyte_server_port: Airbyte server port to connect to. airbyte_api_version: Airbyte API version to use. timeout: Timeout in seconds on the `httpx.AsyncClient`. Returns: Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: ```python import gzip from prefect import flow, task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere( airbyte_configuration: bytes somewhere: str = 'my_destination.gz',' ): with gzip.open('my_destination.gz', 'wb') as f: f.write(airbyte_configuration) @flow def example_export_configuration_flow(): # Run other tasks and subflows here airbyte_config = export_configuration( airbyte_server=AirbyteServer.load(\"oss-airbyte\") ) zip_and_write_somewhere(airbyte_config=airbyte_config) example_trigger_sync_flow() ``` \"\"\" logger = get_run_logger () if not airbyte_server : warn ( \"The use of `airbyte_server_host`, `airbyte_server_port`, and \" \"`airbyte_api_version` is deprecated and will be removed in a \" \"future release. Please pass an `airbyte_server` block to this \" \"task instead.\" , DeprecationWarning , stacklevel = 2 , ) if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): airbyte_server = AirbyteServer ( server_host = airbyte_server_host or \"localhost\" , server_port = airbyte_server_port or 8000 , api_version = airbyte_api_version or \"v1\" , ) else : airbyte_server = AirbyteServer () else : if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): logger . info ( \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \" \"and `airbyte_server_port` because `airbyte_server` block \" \" was passed. Using API URL from `airbyte_server` block: \" f \" { airbyte_server . base_url !r} .\" ) async with airbyte_server . get_client ( logger = logger , timeout = timeout ) as airbyte_client : logger . info ( \"Initiating export of Airbyte configuration\" ) return await airbyte_client . export_configuration ()","title":"Configuration"},{"location":"configuration/#prefect_airbyte.configuration","text":"Tasks for updating and fetching Airbyte configurations","title":"configuration"},{"location":"configuration/#prefect_airbyte.configuration-classes","text":"","title":"Classes"},{"location":"configuration/#prefect_airbyte.configuration-functions","text":"","title":"Functions"},{"location":"configuration/#prefect_airbyte.configuration.export_configuration","text":"Prefect Task that exports an Airbyte configuration via {airbyte_server_host}/api/v1/deployment/export . As of prefect-airbyte==0.1.3 , the kwargs airbyte_server_host and airbyte_server_port can be replaced by passing an airbyte_server block instance to generate the AirbyteClient . Using the airbyte_server block is preferred, but the individual kwargs remain for backwards compatibility. Parameters: Name Type Description Default airbyte_server Optional [ AirbyteServer ] An AirbyteServer block for generating an AirbyteClient . None airbyte_server_host Optional [ str ] Airbyte server host to connect to. None airbyte_server_port Optional [ int ] Airbyte server port to connect to. None airbyte_api_version Optional [ str ] Airbyte API version to use. None timeout int Timeout in seconds on the httpx.AsyncClient . 5 Returns: Type Description bytes Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: import gzip from prefect import flow , task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere ( airbyte_configuration : bytes somewhere : str = 'my_destination.gz' , ' ): with gzip . open ( 'my_destination.gz' , 'wb' ) as f : f . write ( airbyte_configuration ) @flow def example_export_configuration_flow (): # Run other tasks and subflows here airbyte_config = export_configuration ( airbyte_server = AirbyteServer . load ( \"oss-airbyte\" ) ) zip_and_write_somewhere ( airbyte_config = airbyte_config ) example_trigger_sync_flow () Source code in prefect_airbyte/configuration.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @task async def export_configuration ( airbyte_server : Optional [ AirbyteServer ] = None , airbyte_server_host : Optional [ str ] = None , airbyte_server_port : Optional [ int ] = None , airbyte_api_version : Optional [ str ] = None , timeout : int = 5 , ) -> bytes : \"\"\" Prefect Task that exports an Airbyte configuration via `{airbyte_server_host}/api/v1/deployment/export`. As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and `airbyte_server_port` can be replaced by passing an `airbyte_server` block instance to generate the `AirbyteClient`. Using the `airbyte_server` block is preferred, but the individual kwargs remain for backwards compatibility. Args: airbyte_server: An `AirbyteServer` block for generating an `AirbyteClient`. airbyte_server_host: Airbyte server host to connect to. airbyte_server_port: Airbyte server port to connect to. airbyte_api_version: Airbyte API version to use. timeout: Timeout in seconds on the `httpx.AsyncClient`. Returns: Bytes containing Airbyte configuration Examples: Flow that writes the Airbyte configuration as a gzip to a filepath: ```python import gzip from prefect import flow, task from prefect_airbyte.configuration import export_configuration from prefect_airbyte.server import AirbyteServer @task def zip_and_write_somewhere( airbyte_configuration: bytes somewhere: str = 'my_destination.gz',' ): with gzip.open('my_destination.gz', 'wb') as f: f.write(airbyte_configuration) @flow def example_export_configuration_flow(): # Run other tasks and subflows here airbyte_config = export_configuration( airbyte_server=AirbyteServer.load(\"oss-airbyte\") ) zip_and_write_somewhere(airbyte_config=airbyte_config) example_trigger_sync_flow() ``` \"\"\" logger = get_run_logger () if not airbyte_server : warn ( \"The use of `airbyte_server_host`, `airbyte_server_port`, and \" \"`airbyte_api_version` is deprecated and will be removed in a \" \"future release. Please pass an `airbyte_server` block to this \" \"task instead.\" , DeprecationWarning , stacklevel = 2 , ) if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): airbyte_server = AirbyteServer ( server_host = airbyte_server_host or \"localhost\" , server_port = airbyte_server_port or 8000 , api_version = airbyte_api_version or \"v1\" , ) else : airbyte_server = AirbyteServer () else : if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): logger . info ( \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \" \"and `airbyte_server_port` because `airbyte_server` block \" \" was passed. Using API URL from `airbyte_server` block: \" f \" { airbyte_server . base_url !r} .\" ) async with airbyte_server . get_client ( logger = logger , timeout = timeout ) as airbyte_client : logger . info ( \"Initiating export of Airbyte configuration\" ) return await airbyte_client . export_configuration ()","title":"export_configuration()"},{"location":"connections/","text":"prefect_airbyte.connections Tasks for connecting to Airbyte and triggering connection syncs Classes AirbyteConnection Bases: JobBlock A block representing an existing Airbyte connection. Attributes: Name Type Description airbyte_server AirbyteServer AirbyteServer block representing the Airbyte instance where the Airbyte connection is defined. connection_id uuid . UUID UUID of the Airbyte Connection to trigger. poll_interval_s int Time in seconds between status checks of the Airbyte sync job. status_updates bool Whether to log job status on each poll of the Airbyte sync job. timeout int Timeout in seconds for requests made by httpx.AsyncClient . Examples: Load an existing AirbyteConnection block: from prefect_airbyte import AirbyteConnection airbyte_connection = AirbyteConnection . load ( \"BLOCK_NAME\" ) Run an Airbyte connection sync as a flow: from prefect import flow from prefect_airbyte import AirbyteConnection from prefect_airbyte.flows import run_connection_sync # this is a flow airbyte_connection = AirbyteConnection . load ( \"BLOCK_NAME\" ) @flow def airbyte_orchestrator (): run_connection_sync ( airbyte_connection ) # now it's a subflow Source code in prefect_airbyte/connections.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 class AirbyteConnection ( JobBlock ): \"\"\"A block representing an existing Airbyte connection. Attributes: airbyte_server: `AirbyteServer` block representing the Airbyte instance where the Airbyte connection is defined. connection_id: UUID of the Airbyte Connection to trigger. poll_interval_s: Time in seconds between status checks of the Airbyte sync job. status_updates: Whether to log job status on each poll of the Airbyte sync job. timeout: Timeout in seconds for requests made by `httpx.AsyncClient`. Examples: Load an existing `AirbyteConnection` block: ```python from prefect_airbyte import AirbyteConnection airbyte_connection = AirbyteConnection.load(\"BLOCK_NAME\") ``` Run an Airbyte connection sync as a flow: ```python from prefect import flow from prefect_airbyte import AirbyteConnection from prefect_airbyte.flows import run_connection_sync # this is a flow airbyte_connection = AirbyteConnection.load(\"BLOCK_NAME\") @flow def airbyte_orchestrator(): run_connection_sync(airbyte_connection) # now it's a subflow ``` \"\"\" _block_type_name = \"Airbyte Connection\" _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/6gm7wsC7ANnKYQsm7oiSYz/aac1ad5e054d35d9e24af8d6ed3aed5f/59758427?h=250\" # noqa: E501 airbyte_server : AirbyteServer = Field ( default =... , description = ( \"AirbyteServer block representing the Airbyte instance \" \"where the Airbyte connection is defined.\" ), ) connection_id : uuid . UUID = Field ( default =... , description = \"UUID of the Airbyte Connection to trigger.\" , ) poll_interval_s : int = Field ( default = 15 , description = \"Time in seconds between status checks of the Airbyte sync job.\" , ) status_updates : bool = Field ( default = False , description = \"Whether to log job status on each poll of the Airbyte sync job.\" , ) timeout : int = Field ( default = 5 , description = \"Timeout in seconds for requests made by httpx.AsyncClient.\" , ) @sync_compatible async def trigger ( self ) -> AirbyteSync : \"\"\"Trigger a sync of the defined Airbyte connection. Returns: An `AirbyteSync` `JobRun` object representing the active sync job. Raises: AirbyteConnectionInactiveException: If the connection is inactive. AirbyteConnectionDeprecatedException: If the connection is deprecated. \"\"\" str_connection_id = str ( self . connection_id ) async with self . airbyte_server . get_client ( logger = self . logger , timeout = self . timeout ) as airbyte_client : self . logger . info ( f \"Triggering Airbyte Connection { self . connection_id } , \" f \"in workspace at { self . airbyte_server . base_url !r} \" ) connection_status = await airbyte_client . get_connection_status ( str_connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : ( job_id , _ ,) = await airbyte_client . trigger_manual_sync_connection ( str_connection_id ) return AirbyteSync ( airbyte_connection = self , job_id = job_id , ) elif connection_status == CONNECTION_STATUS_INACTIVE : raise err . AirbyteConnectionInactiveException ( f \"Connection: { self . connection_id !r} is inactive\" f \"Please enable the connection { self . connection_id !r} \" \"in your Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : raise err . AirbyeConnectionDeprecatedException ( f \"Connection { self . connection_id !r} is deprecated.\" ) Functions trigger async Trigger a sync of the defined Airbyte connection. Returns: Type Description AirbyteSync An AirbyteSync JobRun object representing the active sync job. Raises: Type Description AirbyteConnectionInactiveException If the connection is inactive. AirbyteConnectionDeprecatedException If the connection is deprecated. Source code in prefect_airbyte/connections.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 @sync_compatible async def trigger ( self ) -> AirbyteSync : \"\"\"Trigger a sync of the defined Airbyte connection. Returns: An `AirbyteSync` `JobRun` object representing the active sync job. Raises: AirbyteConnectionInactiveException: If the connection is inactive. AirbyteConnectionDeprecatedException: If the connection is deprecated. \"\"\" str_connection_id = str ( self . connection_id ) async with self . airbyte_server . get_client ( logger = self . logger , timeout = self . timeout ) as airbyte_client : self . logger . info ( f \"Triggering Airbyte Connection { self . connection_id } , \" f \"in workspace at { self . airbyte_server . base_url !r} \" ) connection_status = await airbyte_client . get_connection_status ( str_connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : ( job_id , _ ,) = await airbyte_client . trigger_manual_sync_connection ( str_connection_id ) return AirbyteSync ( airbyte_connection = self , job_id = job_id , ) elif connection_status == CONNECTION_STATUS_INACTIVE : raise err . AirbyteConnectionInactiveException ( f \"Connection: { self . connection_id !r} is inactive\" f \"Please enable the connection { self . connection_id !r} \" \"in your Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : raise err . AirbyeConnectionDeprecatedException ( f \"Connection { self . connection_id !r} is deprecated.\" ) AirbyteSync Bases: JobRun A JobRun representing an Airbyte sync job. Source code in prefect_airbyte/connections.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 class AirbyteSync ( JobRun ): \"\"\"A `JobRun` representing an Airbyte sync job.\"\"\" def __init__ ( self , airbyte_connection : \"AirbyteConnection\" , job_id : int ): self . airbyte_connection : \"AirbyteConnection\" = airbyte_connection self . job_id : int = job_id self . _records_synced : int = 0 @sync_compatible async def wait_for_completion ( self ): \"\"\"Wait for the `AirbyteConnection` sync to reach a terminal state. Raises: AirbyteSyncJobFailed: If the sync job fails. \"\"\" async with self . airbyte_connection . airbyte_server . get_client ( logger = self . airbyte_connection . logger , timeout = self . airbyte_connection . timeout , ) as airbyte_client : job_status = JOB_STATUS_PENDING while job_status not in terminal_job_statuses : job_info = await airbyte_client . get_job_info ( self . job_id ) job_status = job_info [ \"job\" ][ \"status\" ] self . _records_synced = job_info [ \"attempts\" ][ - 1 ][ \"attempt\" ] . get ( \"recordsSynced\" , 0 ) # pending\u2503running\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : self . logger . info ( f \"Job { self . job_id } succeeded.\" ) elif job_status in [ JOB_STATUS_FAILED , JOB_STATUS_CANCELLED ]: self . logger . error ( f \"Job { self . job_id } { job_status } .\" ) raise err . AirbyteSyncJobFailed ( f \"Job { self . job_id } { job_status } .\" ) else : if self . airbyte_connection . status_updates : self . logger . info ( job_status ) # wait for next poll interval await sleep ( self . airbyte_connection . poll_interval_s ) @sync_compatible async def fetch_result ( self ) -> AirbyteSyncResult : \"\"\"Fetch the result of the `AirbyteSync`. Returns: `AirbyteSyncResult`: object containing metadata for the `AirbyteSync`. \"\"\" async with self . airbyte_connection . airbyte_server . get_client ( logger = self . airbyte_connection . logger , timeout = self . airbyte_connection . timeout , ) as airbyte_client : job_info = await airbyte_client . get_job_info ( self . job_id ) job_status = job_info [ \"job\" ][ \"status\" ] job_created_at = job_info [ \"job\" ][ \"createdAt\" ] job_updated_at = job_info [ \"job\" ][ \"updatedAt\" ] return AirbyteSyncResult ( created_at = job_created_at , job_id = self . job_id , job_status = job_status , records_synced = self . _records_synced , updated_at = job_updated_at , ) Functions fetch_result async Fetch the result of the AirbyteSync . Returns: Type Description AirbyteSyncResult AirbyteSyncResult : object containing metadata for the AirbyteSync . Source code in prefect_airbyte/connections.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 @sync_compatible async def fetch_result ( self ) -> AirbyteSyncResult : \"\"\"Fetch the result of the `AirbyteSync`. Returns: `AirbyteSyncResult`: object containing metadata for the `AirbyteSync`. \"\"\" async with self . airbyte_connection . airbyte_server . get_client ( logger = self . airbyte_connection . logger , timeout = self . airbyte_connection . timeout , ) as airbyte_client : job_info = await airbyte_client . get_job_info ( self . job_id ) job_status = job_info [ \"job\" ][ \"status\" ] job_created_at = job_info [ \"job\" ][ \"createdAt\" ] job_updated_at = job_info [ \"job\" ][ \"updatedAt\" ] return AirbyteSyncResult ( created_at = job_created_at , job_id = self . job_id , job_status = job_status , records_synced = self . _records_synced , updated_at = job_updated_at , ) wait_for_completion async Wait for the AirbyteConnection sync to reach a terminal state. Raises: Type Description AirbyteSyncJobFailed If the sync job fails. Source code in prefect_airbyte/connections.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 @sync_compatible async def wait_for_completion ( self ): \"\"\"Wait for the `AirbyteConnection` sync to reach a terminal state. Raises: AirbyteSyncJobFailed: If the sync job fails. \"\"\" async with self . airbyte_connection . airbyte_server . get_client ( logger = self . airbyte_connection . logger , timeout = self . airbyte_connection . timeout , ) as airbyte_client : job_status = JOB_STATUS_PENDING while job_status not in terminal_job_statuses : job_info = await airbyte_client . get_job_info ( self . job_id ) job_status = job_info [ \"job\" ][ \"status\" ] self . _records_synced = job_info [ \"attempts\" ][ - 1 ][ \"attempt\" ] . get ( \"recordsSynced\" , 0 ) # pending\u2503running\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : self . logger . info ( f \"Job { self . job_id } succeeded.\" ) elif job_status in [ JOB_STATUS_FAILED , JOB_STATUS_CANCELLED ]: self . logger . error ( f \"Job { self . job_id } { job_status } .\" ) raise err . AirbyteSyncJobFailed ( f \"Job { self . job_id } { job_status } .\" ) else : if self . airbyte_connection . status_updates : self . logger . info ( job_status ) # wait for next poll interval await sleep ( self . airbyte_connection . poll_interval_s ) AirbyteSyncResult Bases: BaseModel Model representing a result from an AirbyteSync job run. Source code in prefect_airbyte/connections.py 197 198 199 200 201 202 203 204 class AirbyteSyncResult ( BaseModel ): \"\"\"Model representing a result from an `AirbyteSync` job run.\"\"\" created_at : datetime job_status : Literal [ \"succeeded\" , \"failed\" , \"pending\" , \"cancelled\" ] job_id : int records_synced : int updated_at : datetime Functions trigger_sync async Prefect Task for triggering an Airbyte connection sync. It is assumed that the user will have previously configured a Source & Destination into a Connection. e.g. MySql -> CSV An invocation of trigger_sync will attempt to start a sync job for the specified connection_id representing the Connection in Airbyte. trigger_sync will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. As of prefect-airbyte==0.1.3 , the kwargs airbyte_server_host and airbyte_server_port can be replaced by passing an airbyte_server block instance to generate the AirbyteClient . Using the airbyte_server block is preferred, but the individual kwargs remain for backwards compatibility. Parameters: Name Type Description Default connection_id str Airbyte connection ID to trigger a sync for. required airbyte_server Optional [ AirbyteServer ] An AirbyteServer block to create an AirbyteClient . None airbyte_server_host Optional [ str ] Airbyte server host to connect to. None airbyte_server_port Optional [ int ] Airbyte server port to connect to. None airbyte_api_version Optional [ str ] Airbyte API version to use. None poll_interval_s int How often to poll Airbyte for sync status. 15 status_updates bool Whether to log sync job status while polling. False timeout int The POST request timeout for the httpx.AsyncClient . 5 Raises: Type Description ValueError If connection_id is not a valid UUID. AirbyteSyncJobFailed If airbyte returns JOB_STATUS_FAILED . AirbyteConnectionInactiveException If a given connection is inactive. AirbyeConnectionDeprecatedException If a given connection is deprecated. Returns: Type Description Dict [ str , Any ] Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( airbyte_server = AirbyteServer . load ( \"oss-airbyte\" ), connection_id = \"your-connection-id-to-sync\" ) example_trigger_sync_flow () Source code in prefect_airbyte/connections.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 @task async def trigger_sync ( connection_id : str , airbyte_server : Optional [ AirbyteServer ] = None , airbyte_server_host : Optional [ str ] = None , airbyte_server_port : Optional [ int ] = None , airbyte_api_version : Optional [ str ] = None , poll_interval_s : int = 15 , status_updates : bool = False , timeout : int = 5 , ) -> Dict [ str , Any ]: \"\"\"Prefect Task for triggering an Airbyte connection sync. *It is assumed that the user will have previously configured a Source & Destination into a Connection.* e.g. MySql -> CSV An invocation of `trigger_sync` will attempt to start a sync job for the specified `connection_id` representing the Connection in Airbyte. `trigger_sync` will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and `airbyte_server_port` can be replaced by passing an `airbyte_server` block instance to generate the `AirbyteClient`. Using the `airbyte_server` block is preferred, but the individual kwargs remain for backwards compatibility. Args: connection_id: Airbyte connection ID to trigger a sync for. airbyte_server: An `AirbyteServer` block to create an `AirbyteClient`. airbyte_server_host: Airbyte server host to connect to. airbyte_server_port: Airbyte server port to connect to. airbyte_api_version: Airbyte API version to use. poll_interval_s: How often to poll Airbyte for sync status. status_updates: Whether to log sync job status while polling. timeout: The POST request `timeout` for the `httpx.AsyncClient`. Raises: ValueError: If `connection_id` is not a valid UUID. AirbyteSyncJobFailed: If airbyte returns `JOB_STATUS_FAILED`. AirbyteConnectionInactiveException: If a given connection is inactive. AirbyeConnectionDeprecatedException: If a given connection is deprecated. Returns: Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: ```python from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow(): # Run other tasks and subflows here trigger_sync( airbyte_server=AirbyteServer.load(\"oss-airbyte\"), connection_id=\"your-connection-id-to-sync\" ) example_trigger_sync_flow() ``` \"\"\" logger = get_run_logger () if not airbyte_server : warn ( \"The use of `airbyte_server_host`, `airbyte_server_port`, and \" \"`airbyte_api_version` is deprecated and will be removed in a \" \"future release. Please pass an `airbyte_server` block to this \" \"task instead.\" , DeprecationWarning , stacklevel = 2 , ) if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): airbyte_server = AirbyteServer ( server_host = airbyte_server_host or \"localhost\" , server_port = airbyte_server_port or 8000 , api_version = airbyte_api_version or \"v1\" , ) else : airbyte_server = AirbyteServer () else : if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): logger . info ( \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \" \"and `airbyte_server_port` because `airbyte_server` block \" \" was passed. Using API URL from `airbyte_server` block: \" f \" { airbyte_server . base_url !r} .\" ) try : uuid . UUID ( connection_id ) except ( TypeError , ValueError ): raise ValueError ( \"Parameter `connection_id` *must* be a valid UUID \\ i.e. 32 hex characters, including hyphens.\" ) async with airbyte_server . get_client ( logger = logger , timeout = timeout ) as airbyte_client : logger . info ( f \"Getting Airbyte Connection { connection_id } , poll interval \" f \" { poll_interval_s } seconds, airbyte_base_url { airbyte_server . base_url } \" ) connection_status = await airbyte_client . get_connection_status ( connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : # Trigger manual sync on the Connection ... ( job_id , job_created_at , ) = await airbyte_client . trigger_manual_sync_connection ( connection_id ) job_status = JOB_STATUS_PENDING while job_status not in terminal_job_statuses : ( job_status , job_created_at , job_updated_at , ) = await airbyte_client . get_job_status ( job_id ) # pending\u2503running\u2503incomplete\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : logger . info ( f \"Job { job_id } succeeded.\" ) elif job_status in [ JOB_STATUS_FAILED , JOB_STATUS_CANCELLED ]: logger . error ( f \"Job { job_id } { job_status } .\" ) raise err . AirbyteSyncJobFailed ( f \"Job { job_id } { job_status } .\" ) else : if status_updates : logger . info ( job_status ) # wait for next poll interval await sleep ( poll_interval_s ) return { \"connection_id\" : connection_id , \"status\" : connection_status , \"job_status\" : job_status , \"job_created_at\" : job_created_at , \"job_updated_at\" : job_updated_at , } elif connection_status == CONNECTION_STATUS_INACTIVE : logger . error ( f \"Connection: { connection_id } is inactive\" \" - you'll need to enable it in your Airbyte instance\" ) raise err . AirbyteConnectionInactiveException ( f \"Please enable the Connection { connection_id } in Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : logger . error ( f \"Connection { connection_id } is deprecated.\" ) raise err . AirbyeConnectionDeprecatedException ( f \"Connection { connection_id } is deprecated.\" )","title":"Connections"},{"location":"connections/#prefect_airbyte.connections","text":"Tasks for connecting to Airbyte and triggering connection syncs","title":"connections"},{"location":"connections/#prefect_airbyte.connections-classes","text":"","title":"Classes"},{"location":"connections/#prefect_airbyte.connections.AirbyteConnection","text":"Bases: JobBlock A block representing an existing Airbyte connection. Attributes: Name Type Description airbyte_server AirbyteServer AirbyteServer block representing the Airbyte instance where the Airbyte connection is defined. connection_id uuid . UUID UUID of the Airbyte Connection to trigger. poll_interval_s int Time in seconds between status checks of the Airbyte sync job. status_updates bool Whether to log job status on each poll of the Airbyte sync job. timeout int Timeout in seconds for requests made by httpx.AsyncClient . Examples: Load an existing AirbyteConnection block: from prefect_airbyte import AirbyteConnection airbyte_connection = AirbyteConnection . load ( \"BLOCK_NAME\" ) Run an Airbyte connection sync as a flow: from prefect import flow from prefect_airbyte import AirbyteConnection from prefect_airbyte.flows import run_connection_sync # this is a flow airbyte_connection = AirbyteConnection . load ( \"BLOCK_NAME\" ) @flow def airbyte_orchestrator (): run_connection_sync ( airbyte_connection ) # now it's a subflow Source code in prefect_airbyte/connections.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 class AirbyteConnection ( JobBlock ): \"\"\"A block representing an existing Airbyte connection. Attributes: airbyte_server: `AirbyteServer` block representing the Airbyte instance where the Airbyte connection is defined. connection_id: UUID of the Airbyte Connection to trigger. poll_interval_s: Time in seconds between status checks of the Airbyte sync job. status_updates: Whether to log job status on each poll of the Airbyte sync job. timeout: Timeout in seconds for requests made by `httpx.AsyncClient`. Examples: Load an existing `AirbyteConnection` block: ```python from prefect_airbyte import AirbyteConnection airbyte_connection = AirbyteConnection.load(\"BLOCK_NAME\") ``` Run an Airbyte connection sync as a flow: ```python from prefect import flow from prefect_airbyte import AirbyteConnection from prefect_airbyte.flows import run_connection_sync # this is a flow airbyte_connection = AirbyteConnection.load(\"BLOCK_NAME\") @flow def airbyte_orchestrator(): run_connection_sync(airbyte_connection) # now it's a subflow ``` \"\"\" _block_type_name = \"Airbyte Connection\" _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/6gm7wsC7ANnKYQsm7oiSYz/aac1ad5e054d35d9e24af8d6ed3aed5f/59758427?h=250\" # noqa: E501 airbyte_server : AirbyteServer = Field ( default =... , description = ( \"AirbyteServer block representing the Airbyte instance \" \"where the Airbyte connection is defined.\" ), ) connection_id : uuid . UUID = Field ( default =... , description = \"UUID of the Airbyte Connection to trigger.\" , ) poll_interval_s : int = Field ( default = 15 , description = \"Time in seconds between status checks of the Airbyte sync job.\" , ) status_updates : bool = Field ( default = False , description = \"Whether to log job status on each poll of the Airbyte sync job.\" , ) timeout : int = Field ( default = 5 , description = \"Timeout in seconds for requests made by httpx.AsyncClient.\" , ) @sync_compatible async def trigger ( self ) -> AirbyteSync : \"\"\"Trigger a sync of the defined Airbyte connection. Returns: An `AirbyteSync` `JobRun` object representing the active sync job. Raises: AirbyteConnectionInactiveException: If the connection is inactive. AirbyteConnectionDeprecatedException: If the connection is deprecated. \"\"\" str_connection_id = str ( self . connection_id ) async with self . airbyte_server . get_client ( logger = self . logger , timeout = self . timeout ) as airbyte_client : self . logger . info ( f \"Triggering Airbyte Connection { self . connection_id } , \" f \"in workspace at { self . airbyte_server . base_url !r} \" ) connection_status = await airbyte_client . get_connection_status ( str_connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : ( job_id , _ ,) = await airbyte_client . trigger_manual_sync_connection ( str_connection_id ) return AirbyteSync ( airbyte_connection = self , job_id = job_id , ) elif connection_status == CONNECTION_STATUS_INACTIVE : raise err . AirbyteConnectionInactiveException ( f \"Connection: { self . connection_id !r} is inactive\" f \"Please enable the connection { self . connection_id !r} \" \"in your Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : raise err . AirbyeConnectionDeprecatedException ( f \"Connection { self . connection_id !r} is deprecated.\" )","title":"AirbyteConnection"},{"location":"connections/#prefect_airbyte.connections.AirbyteConnection-functions","text":"","title":"Functions"},{"location":"connections/#prefect_airbyte.connections.AirbyteConnection.trigger","text":"Trigger a sync of the defined Airbyte connection. Returns: Type Description AirbyteSync An AirbyteSync JobRun object representing the active sync job. Raises: Type Description AirbyteConnectionInactiveException If the connection is inactive. AirbyteConnectionDeprecatedException If the connection is deprecated. Source code in prefect_airbyte/connections.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 @sync_compatible async def trigger ( self ) -> AirbyteSync : \"\"\"Trigger a sync of the defined Airbyte connection. Returns: An `AirbyteSync` `JobRun` object representing the active sync job. Raises: AirbyteConnectionInactiveException: If the connection is inactive. AirbyteConnectionDeprecatedException: If the connection is deprecated. \"\"\" str_connection_id = str ( self . connection_id ) async with self . airbyte_server . get_client ( logger = self . logger , timeout = self . timeout ) as airbyte_client : self . logger . info ( f \"Triggering Airbyte Connection { self . connection_id } , \" f \"in workspace at { self . airbyte_server . base_url !r} \" ) connection_status = await airbyte_client . get_connection_status ( str_connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : ( job_id , _ ,) = await airbyte_client . trigger_manual_sync_connection ( str_connection_id ) return AirbyteSync ( airbyte_connection = self , job_id = job_id , ) elif connection_status == CONNECTION_STATUS_INACTIVE : raise err . AirbyteConnectionInactiveException ( f \"Connection: { self . connection_id !r} is inactive\" f \"Please enable the connection { self . connection_id !r} \" \"in your Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : raise err . AirbyeConnectionDeprecatedException ( f \"Connection { self . connection_id !r} is deprecated.\" )","title":"trigger()"},{"location":"connections/#prefect_airbyte.connections.AirbyteSync","text":"Bases: JobRun A JobRun representing an Airbyte sync job. Source code in prefect_airbyte/connections.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 class AirbyteSync ( JobRun ): \"\"\"A `JobRun` representing an Airbyte sync job.\"\"\" def __init__ ( self , airbyte_connection : \"AirbyteConnection\" , job_id : int ): self . airbyte_connection : \"AirbyteConnection\" = airbyte_connection self . job_id : int = job_id self . _records_synced : int = 0 @sync_compatible async def wait_for_completion ( self ): \"\"\"Wait for the `AirbyteConnection` sync to reach a terminal state. Raises: AirbyteSyncJobFailed: If the sync job fails. \"\"\" async with self . airbyte_connection . airbyte_server . get_client ( logger = self . airbyte_connection . logger , timeout = self . airbyte_connection . timeout , ) as airbyte_client : job_status = JOB_STATUS_PENDING while job_status not in terminal_job_statuses : job_info = await airbyte_client . get_job_info ( self . job_id ) job_status = job_info [ \"job\" ][ \"status\" ] self . _records_synced = job_info [ \"attempts\" ][ - 1 ][ \"attempt\" ] . get ( \"recordsSynced\" , 0 ) # pending\u2503running\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : self . logger . info ( f \"Job { self . job_id } succeeded.\" ) elif job_status in [ JOB_STATUS_FAILED , JOB_STATUS_CANCELLED ]: self . logger . error ( f \"Job { self . job_id } { job_status } .\" ) raise err . AirbyteSyncJobFailed ( f \"Job { self . job_id } { job_status } .\" ) else : if self . airbyte_connection . status_updates : self . logger . info ( job_status ) # wait for next poll interval await sleep ( self . airbyte_connection . poll_interval_s ) @sync_compatible async def fetch_result ( self ) -> AirbyteSyncResult : \"\"\"Fetch the result of the `AirbyteSync`. Returns: `AirbyteSyncResult`: object containing metadata for the `AirbyteSync`. \"\"\" async with self . airbyte_connection . airbyte_server . get_client ( logger = self . airbyte_connection . logger , timeout = self . airbyte_connection . timeout , ) as airbyte_client : job_info = await airbyte_client . get_job_info ( self . job_id ) job_status = job_info [ \"job\" ][ \"status\" ] job_created_at = job_info [ \"job\" ][ \"createdAt\" ] job_updated_at = job_info [ \"job\" ][ \"updatedAt\" ] return AirbyteSyncResult ( created_at = job_created_at , job_id = self . job_id , job_status = job_status , records_synced = self . _records_synced , updated_at = job_updated_at , )","title":"AirbyteSync"},{"location":"connections/#prefect_airbyte.connections.AirbyteSync-functions","text":"","title":"Functions"},{"location":"connections/#prefect_airbyte.connections.AirbyteSync.fetch_result","text":"Fetch the result of the AirbyteSync . Returns: Type Description AirbyteSyncResult AirbyteSyncResult : object containing metadata for the AirbyteSync . Source code in prefect_airbyte/connections.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 @sync_compatible async def fetch_result ( self ) -> AirbyteSyncResult : \"\"\"Fetch the result of the `AirbyteSync`. Returns: `AirbyteSyncResult`: object containing metadata for the `AirbyteSync`. \"\"\" async with self . airbyte_connection . airbyte_server . get_client ( logger = self . airbyte_connection . logger , timeout = self . airbyte_connection . timeout , ) as airbyte_client : job_info = await airbyte_client . get_job_info ( self . job_id ) job_status = job_info [ \"job\" ][ \"status\" ] job_created_at = job_info [ \"job\" ][ \"createdAt\" ] job_updated_at = job_info [ \"job\" ][ \"updatedAt\" ] return AirbyteSyncResult ( created_at = job_created_at , job_id = self . job_id , job_status = job_status , records_synced = self . _records_synced , updated_at = job_updated_at , )","title":"fetch_result()"},{"location":"connections/#prefect_airbyte.connections.AirbyteSync.wait_for_completion","text":"Wait for the AirbyteConnection sync to reach a terminal state. Raises: Type Description AirbyteSyncJobFailed If the sync job fails. Source code in prefect_airbyte/connections.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 @sync_compatible async def wait_for_completion ( self ): \"\"\"Wait for the `AirbyteConnection` sync to reach a terminal state. Raises: AirbyteSyncJobFailed: If the sync job fails. \"\"\" async with self . airbyte_connection . airbyte_server . get_client ( logger = self . airbyte_connection . logger , timeout = self . airbyte_connection . timeout , ) as airbyte_client : job_status = JOB_STATUS_PENDING while job_status not in terminal_job_statuses : job_info = await airbyte_client . get_job_info ( self . job_id ) job_status = job_info [ \"job\" ][ \"status\" ] self . _records_synced = job_info [ \"attempts\" ][ - 1 ][ \"attempt\" ] . get ( \"recordsSynced\" , 0 ) # pending\u2503running\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : self . logger . info ( f \"Job { self . job_id } succeeded.\" ) elif job_status in [ JOB_STATUS_FAILED , JOB_STATUS_CANCELLED ]: self . logger . error ( f \"Job { self . job_id } { job_status } .\" ) raise err . AirbyteSyncJobFailed ( f \"Job { self . job_id } { job_status } .\" ) else : if self . airbyte_connection . status_updates : self . logger . info ( job_status ) # wait for next poll interval await sleep ( self . airbyte_connection . poll_interval_s )","title":"wait_for_completion()"},{"location":"connections/#prefect_airbyte.connections.AirbyteSyncResult","text":"Bases: BaseModel Model representing a result from an AirbyteSync job run. Source code in prefect_airbyte/connections.py 197 198 199 200 201 202 203 204 class AirbyteSyncResult ( BaseModel ): \"\"\"Model representing a result from an `AirbyteSync` job run.\"\"\" created_at : datetime job_status : Literal [ \"succeeded\" , \"failed\" , \"pending\" , \"cancelled\" ] job_id : int records_synced : int updated_at : datetime","title":"AirbyteSyncResult"},{"location":"connections/#prefect_airbyte.connections-functions","text":"","title":"Functions"},{"location":"connections/#prefect_airbyte.connections.trigger_sync","text":"Prefect Task for triggering an Airbyte connection sync. It is assumed that the user will have previously configured a Source & Destination into a Connection. e.g. MySql -> CSV An invocation of trigger_sync will attempt to start a sync job for the specified connection_id representing the Connection in Airbyte. trigger_sync will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. As of prefect-airbyte==0.1.3 , the kwargs airbyte_server_host and airbyte_server_port can be replaced by passing an airbyte_server block instance to generate the AirbyteClient . Using the airbyte_server block is preferred, but the individual kwargs remain for backwards compatibility. Parameters: Name Type Description Default connection_id str Airbyte connection ID to trigger a sync for. required airbyte_server Optional [ AirbyteServer ] An AirbyteServer block to create an AirbyteClient . None airbyte_server_host Optional [ str ] Airbyte server host to connect to. None airbyte_server_port Optional [ int ] Airbyte server port to connect to. None airbyte_api_version Optional [ str ] Airbyte API version to use. None poll_interval_s int How often to poll Airbyte for sync status. 15 status_updates bool Whether to log sync job status while polling. False timeout int The POST request timeout for the httpx.AsyncClient . 5 Raises: Type Description ValueError If connection_id is not a valid UUID. AirbyteSyncJobFailed If airbyte returns JOB_STATUS_FAILED . AirbyteConnectionInactiveException If a given connection is inactive. AirbyeConnectionDeprecatedException If a given connection is deprecated. Returns: Type Description Dict [ str , Any ] Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow (): # Run other tasks and subflows here trigger_sync ( airbyte_server = AirbyteServer . load ( \"oss-airbyte\" ), connection_id = \"your-connection-id-to-sync\" ) example_trigger_sync_flow () Source code in prefect_airbyte/connections.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 @task async def trigger_sync ( connection_id : str , airbyte_server : Optional [ AirbyteServer ] = None , airbyte_server_host : Optional [ str ] = None , airbyte_server_port : Optional [ int ] = None , airbyte_api_version : Optional [ str ] = None , poll_interval_s : int = 15 , status_updates : bool = False , timeout : int = 5 , ) -> Dict [ str , Any ]: \"\"\"Prefect Task for triggering an Airbyte connection sync. *It is assumed that the user will have previously configured a Source & Destination into a Connection.* e.g. MySql -> CSV An invocation of `trigger_sync` will attempt to start a sync job for the specified `connection_id` representing the Connection in Airbyte. `trigger_sync` will poll Airbyte Server for the Connection status and will only complete when the sync has completed or when it receives an error status code from an API call. As of `prefect-airbyte==0.1.3`, the kwargs `airbyte_server_host` and `airbyte_server_port` can be replaced by passing an `airbyte_server` block instance to generate the `AirbyteClient`. Using the `airbyte_server` block is preferred, but the individual kwargs remain for backwards compatibility. Args: connection_id: Airbyte connection ID to trigger a sync for. airbyte_server: An `AirbyteServer` block to create an `AirbyteClient`. airbyte_server_host: Airbyte server host to connect to. airbyte_server_port: Airbyte server port to connect to. airbyte_api_version: Airbyte API version to use. poll_interval_s: How often to poll Airbyte for sync status. status_updates: Whether to log sync job status while polling. timeout: The POST request `timeout` for the `httpx.AsyncClient`. Raises: ValueError: If `connection_id` is not a valid UUID. AirbyteSyncJobFailed: If airbyte returns `JOB_STATUS_FAILED`. AirbyteConnectionInactiveException: If a given connection is inactive. AirbyeConnectionDeprecatedException: If a given connection is deprecated. Returns: Job metadata, including the connection ID and final status of the sync. Examples: Flow that triggers an Airybte connection sync: ```python from prefect import flow from prefect_airbyte.connections import trigger_sync from prefect_airbyte.server import AirbyteServer @flow def example_trigger_sync_flow(): # Run other tasks and subflows here trigger_sync( airbyte_server=AirbyteServer.load(\"oss-airbyte\"), connection_id=\"your-connection-id-to-sync\" ) example_trigger_sync_flow() ``` \"\"\" logger = get_run_logger () if not airbyte_server : warn ( \"The use of `airbyte_server_host`, `airbyte_server_port`, and \" \"`airbyte_api_version` is deprecated and will be removed in a \" \"future release. Please pass an `airbyte_server` block to this \" \"task instead.\" , DeprecationWarning , stacklevel = 2 , ) if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): airbyte_server = AirbyteServer ( server_host = airbyte_server_host or \"localhost\" , server_port = airbyte_server_port or 8000 , api_version = airbyte_api_version or \"v1\" , ) else : airbyte_server = AirbyteServer () else : if any ([ airbyte_server_host , airbyte_server_port , airbyte_api_version ]): logger . info ( \"Ignoring `airbyte_server_host`, `airbyte_api_version`, \" \"and `airbyte_server_port` because `airbyte_server` block \" \" was passed. Using API URL from `airbyte_server` block: \" f \" { airbyte_server . base_url !r} .\" ) try : uuid . UUID ( connection_id ) except ( TypeError , ValueError ): raise ValueError ( \"Parameter `connection_id` *must* be a valid UUID \\ i.e. 32 hex characters, including hyphens.\" ) async with airbyte_server . get_client ( logger = logger , timeout = timeout ) as airbyte_client : logger . info ( f \"Getting Airbyte Connection { connection_id } , poll interval \" f \" { poll_interval_s } seconds, airbyte_base_url { airbyte_server . base_url } \" ) connection_status = await airbyte_client . get_connection_status ( connection_id ) if connection_status == CONNECTION_STATUS_ACTIVE : # Trigger manual sync on the Connection ... ( job_id , job_created_at , ) = await airbyte_client . trigger_manual_sync_connection ( connection_id ) job_status = JOB_STATUS_PENDING while job_status not in terminal_job_statuses : ( job_status , job_created_at , job_updated_at , ) = await airbyte_client . get_job_status ( job_id ) # pending\u2503running\u2503incomplete\u2503failed\u2503succeeded\u2503cancelled if job_status == JOB_STATUS_SUCCEEDED : logger . info ( f \"Job { job_id } succeeded.\" ) elif job_status in [ JOB_STATUS_FAILED , JOB_STATUS_CANCELLED ]: logger . error ( f \"Job { job_id } { job_status } .\" ) raise err . AirbyteSyncJobFailed ( f \"Job { job_id } { job_status } .\" ) else : if status_updates : logger . info ( job_status ) # wait for next poll interval await sleep ( poll_interval_s ) return { \"connection_id\" : connection_id , \"status\" : connection_status , \"job_status\" : job_status , \"job_created_at\" : job_created_at , \"job_updated_at\" : job_updated_at , } elif connection_status == CONNECTION_STATUS_INACTIVE : logger . error ( f \"Connection: { connection_id } is inactive\" \" - you'll need to enable it in your Airbyte instance\" ) raise err . AirbyteConnectionInactiveException ( f \"Please enable the Connection { connection_id } in Airbyte instance.\" ) elif connection_status == CONNECTION_STATUS_DEPRECATED : logger . error ( f \"Connection { connection_id } is deprecated.\" ) raise err . AirbyeConnectionDeprecatedException ( f \"Connection { connection_id } is deprecated.\" )","title":"trigger_sync()"},{"location":"exceptions/","text":"prefect_airbyte.exceptions Exceptions to raise indicating issues throughout prefect_airbyte Classes AirbyeConnectionDeprecatedException Bases: Exception Raises when a specified Airbyte connection is deprecated. Source code in prefect_airbyte/exceptions.py 40 41 42 43 class AirbyeConnectionDeprecatedException ( Exception ): \"\"\" Raises when a specified Airbyte connection is deprecated. \"\"\" AirbyteConnectionInactiveException Bases: Exception Raises when a specified Airbyte connection is inactive. Source code in prefect_airbyte/exceptions.py 34 35 36 37 class AirbyteConnectionInactiveException ( Exception ): \"\"\" Raises when a specified Airbyte connection is inactive. \"\"\" AirbyteExportConfigurationFailed Bases: Exception Raises when an Airbyte configuration export fails. Source code in prefect_airbyte/exceptions.py 28 29 30 31 class AirbyteExportConfigurationFailed ( Exception ): \"\"\" Raises when an Airbyte configuration export fails. \"\"\" AirbyteServerNotHealthyException Bases: Exception Raises when a specified Airbyte instance returns an unhealthy response. Source code in prefect_airbyte/exceptions.py 10 11 12 13 class AirbyteServerNotHealthyException ( Exception ): \"\"\" Raises when a specified Airbyte instance returns an unhealthy response. \"\"\" AirbyteSyncJobFailed Bases: Exception Raises when a specified Airbyte Sync Job fails. Source code in prefect_airbyte/exceptions.py 22 23 24 25 class AirbyteSyncJobFailed ( Exception ): \"\"\" Raises when a specified Airbyte Sync Job fails. \"\"\" ConnectionNotFoundException Bases: Exception Raises when a requested Airbyte connection cannot be found. Source code in prefect_airbyte/exceptions.py 4 5 6 7 class ConnectionNotFoundException ( Exception ): \"\"\" Raises when a requested Airbyte connection cannot be found. \"\"\" JobNotFoundException Bases: Exception Raises when a requested Airbyte job cannot be found. Source code in prefect_airbyte/exceptions.py 16 17 18 19 class JobNotFoundException ( Exception ): \"\"\" Raises when a requested Airbyte job cannot be found. \"\"\"","title":"Exceptions"},{"location":"exceptions/#prefect_airbyte.exceptions","text":"Exceptions to raise indicating issues throughout prefect_airbyte","title":"exceptions"},{"location":"exceptions/#prefect_airbyte.exceptions-classes","text":"","title":"Classes"},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyeConnectionDeprecatedException","text":"Bases: Exception Raises when a specified Airbyte connection is deprecated. Source code in prefect_airbyte/exceptions.py 40 41 42 43 class AirbyeConnectionDeprecatedException ( Exception ): \"\"\" Raises when a specified Airbyte connection is deprecated. \"\"\"","title":"AirbyeConnectionDeprecatedException"},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyteConnectionInactiveException","text":"Bases: Exception Raises when a specified Airbyte connection is inactive. Source code in prefect_airbyte/exceptions.py 34 35 36 37 class AirbyteConnectionInactiveException ( Exception ): \"\"\" Raises when a specified Airbyte connection is inactive. \"\"\"","title":"AirbyteConnectionInactiveException"},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyteExportConfigurationFailed","text":"Bases: Exception Raises when an Airbyte configuration export fails. Source code in prefect_airbyte/exceptions.py 28 29 30 31 class AirbyteExportConfigurationFailed ( Exception ): \"\"\" Raises when an Airbyte configuration export fails. \"\"\"","title":"AirbyteExportConfigurationFailed"},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyteServerNotHealthyException","text":"Bases: Exception Raises when a specified Airbyte instance returns an unhealthy response. Source code in prefect_airbyte/exceptions.py 10 11 12 13 class AirbyteServerNotHealthyException ( Exception ): \"\"\" Raises when a specified Airbyte instance returns an unhealthy response. \"\"\"","title":"AirbyteServerNotHealthyException"},{"location":"exceptions/#prefect_airbyte.exceptions.AirbyteSyncJobFailed","text":"Bases: Exception Raises when a specified Airbyte Sync Job fails. Source code in prefect_airbyte/exceptions.py 22 23 24 25 class AirbyteSyncJobFailed ( Exception ): \"\"\" Raises when a specified Airbyte Sync Job fails. \"\"\"","title":"AirbyteSyncJobFailed"},{"location":"exceptions/#prefect_airbyte.exceptions.ConnectionNotFoundException","text":"Bases: Exception Raises when a requested Airbyte connection cannot be found. Source code in prefect_airbyte/exceptions.py 4 5 6 7 class ConnectionNotFoundException ( Exception ): \"\"\" Raises when a requested Airbyte connection cannot be found. \"\"\"","title":"ConnectionNotFoundException"},{"location":"exceptions/#prefect_airbyte.exceptions.JobNotFoundException","text":"Bases: Exception Raises when a requested Airbyte job cannot be found. Source code in prefect_airbyte/exceptions.py 16 17 18 19 class JobNotFoundException ( Exception ): \"\"\" Raises when a requested Airbyte job cannot be found. \"\"\"","title":"JobNotFoundException"},{"location":"flows/","text":"prefect_airbyte.flows Flows for interacting with Airbyte. Classes Functions run_connection_sync async A flow that triggers a sync of an Airbyte connection and waits for it to complete. Parameters: Name Type Description Default airbyte_connection AirbyteConnection AirbyteConnection representing the Airbyte connection to trigger and wait for completion of. required Returns: Type Description AirbyteSyncResult AirbyteSyncResult : Model containing metadata for the AirbyteSync . Example Define a flow that runs an Airbyte connection sync: from prefect import flow from prefect_airbyte.server import AirbyteServer from prefect_airbyte.connections import AirbyteConnection from prefect_airbyte.flows import run_connection_sync airbyte_server = AirbyteServer ( server_host = \"localhost\" , server_port = 8000 ) connection = AirbyteConnection ( airbyte_server = airbyte_server , connection_id = \"<YOUR-AIRBYTE-CONNECTION-UUID>\" ) @flow def airbyte_sync_flow (): # do some things airbyte_sync_result = run_connection_sync ( airbyte_connection = connection ) print ( airbyte_sync_result . records_synced ) # do some other things, like trigger DBT based on number of new raw records Source code in prefect_airbyte/flows.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @flow async def run_connection_sync ( airbyte_connection : AirbyteConnection , ) -> AirbyteSyncResult : \"\"\"A flow that triggers a sync of an Airbyte connection and waits for it to complete. Args: airbyte_connection: `AirbyteConnection` representing the Airbyte connection to trigger and wait for completion of. Returns: `AirbyteSyncResult`: Model containing metadata for the `AirbyteSync`. Example: Define a flow that runs an Airbyte connection sync: ```python from prefect import flow from prefect_airbyte.server import AirbyteServer from prefect_airbyte.connections import AirbyteConnection from prefect_airbyte.flows import run_connection_sync airbyte_server = AirbyteServer( server_host=\"localhost\", server_port=8000 ) connection = AirbyteConnection( airbyte_server=airbyte_server, connection_id=\"<YOUR-AIRBYTE-CONNECTION-UUID>\" ) @flow def airbyte_sync_flow(): # do some things airbyte_sync_result = run_connection_sync( airbyte_connection=connection ) print(airbyte_sync_result.records_synced) # do some other things, like trigger DBT based on number of new raw records ``` \"\"\" # TODO: refactor block method calls to avoid using <sync_compatible_method>.aio # we currently need to do this because of the deadlock caused by calling # a sync task within an async flow # see [this issue](https://github.com/PrefectHQ/prefect/issues/7551) airbyte_sync = await task ( airbyte_connection . trigger . aio )( airbyte_connection ) await task ( airbyte_sync . wait_for_completion . aio )( airbyte_sync ) return await task ( airbyte_sync . fetch_result . aio )( airbyte_sync )","title":"Flows"},{"location":"flows/#prefect_airbyte.flows","text":"Flows for interacting with Airbyte.","title":"flows"},{"location":"flows/#prefect_airbyte.flows-classes","text":"","title":"Classes"},{"location":"flows/#prefect_airbyte.flows-functions","text":"","title":"Functions"},{"location":"flows/#prefect_airbyte.flows.run_connection_sync","text":"A flow that triggers a sync of an Airbyte connection and waits for it to complete. Parameters: Name Type Description Default airbyte_connection AirbyteConnection AirbyteConnection representing the Airbyte connection to trigger and wait for completion of. required Returns: Type Description AirbyteSyncResult AirbyteSyncResult : Model containing metadata for the AirbyteSync . Example Define a flow that runs an Airbyte connection sync: from prefect import flow from prefect_airbyte.server import AirbyteServer from prefect_airbyte.connections import AirbyteConnection from prefect_airbyte.flows import run_connection_sync airbyte_server = AirbyteServer ( server_host = \"localhost\" , server_port = 8000 ) connection = AirbyteConnection ( airbyte_server = airbyte_server , connection_id = \"<YOUR-AIRBYTE-CONNECTION-UUID>\" ) @flow def airbyte_sync_flow (): # do some things airbyte_sync_result = run_connection_sync ( airbyte_connection = connection ) print ( airbyte_sync_result . records_synced ) # do some other things, like trigger DBT based on number of new raw records Source code in prefect_airbyte/flows.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @flow async def run_connection_sync ( airbyte_connection : AirbyteConnection , ) -> AirbyteSyncResult : \"\"\"A flow that triggers a sync of an Airbyte connection and waits for it to complete. Args: airbyte_connection: `AirbyteConnection` representing the Airbyte connection to trigger and wait for completion of. Returns: `AirbyteSyncResult`: Model containing metadata for the `AirbyteSync`. Example: Define a flow that runs an Airbyte connection sync: ```python from prefect import flow from prefect_airbyte.server import AirbyteServer from prefect_airbyte.connections import AirbyteConnection from prefect_airbyte.flows import run_connection_sync airbyte_server = AirbyteServer( server_host=\"localhost\", server_port=8000 ) connection = AirbyteConnection( airbyte_server=airbyte_server, connection_id=\"<YOUR-AIRBYTE-CONNECTION-UUID>\" ) @flow def airbyte_sync_flow(): # do some things airbyte_sync_result = run_connection_sync( airbyte_connection=connection ) print(airbyte_sync_result.records_synced) # do some other things, like trigger DBT based on number of new raw records ``` \"\"\" # TODO: refactor block method calls to avoid using <sync_compatible_method>.aio # we currently need to do this because of the deadlock caused by calling # a sync task within an async flow # see [this issue](https://github.com/PrefectHQ/prefect/issues/7551) airbyte_sync = await task ( airbyte_connection . trigger . aio )( airbyte_connection ) await task ( airbyte_sync . wait_for_completion . aio )( airbyte_sync ) return await task ( airbyte_sync . fetch_result . aio )( airbyte_sync )","title":"run_connection_sync()"},{"location":"server/","text":"prefect_airbyte.server A module for defining OSS Airbyte interactions with Prefect. Classes AirbyteServer Bases: Block A block representing an Airbyte server for generating AirbyteClient instances. Attributes: Name Type Description username str Username for Airbyte API. password SecretStr Password for Airbyte API. server_host str Hostname for Airbyte API. server_port int Port for Airbyte API. api_version str Version of Airbyte API to use. use_ssl bool Whether to use a secure url for calls to the Airbyte API. Example from prefect_airbyte.server import AirbyteServer server = AirbyteServer . load ( \"BLOCK_NAME\" ) Source code in prefect_airbyte/server.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class AirbyteServer ( Block ): \"\"\"A block representing an Airbyte server for generating `AirbyteClient` instances. Attributes: username: Username for Airbyte API. password: Password for Airbyte API. server_host: Hostname for Airbyte API. server_port: Port for Airbyte API. api_version: Version of Airbyte API to use. use_ssl: Whether to use a secure url for calls to the Airbyte API. Example: ```python from prefect_airbyte.server import AirbyteServer server = AirbyteServer.load(\"BLOCK_NAME\") ``` \"\"\" _block_type_name = \"Airbyte Server\" _block_type_slug = \"airbyte-server\" _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/6gm7wsC7ANnKYQsm7oiSYz/aac1ad5e054d35d9e24af8d6ed3aed5f/59758427?h=250\" # noqa username : str = Field ( default = \"airbyte\" , description = \"Username to authenticate with Airbyte API.\" , ) password : SecretStr = Field ( default = SecretStr ( \"password\" ), description = \"Password to authenticate with Airbyte API.\" , ) server_host : str = Field ( default = \"localhost\" , description = \"Host address of Airbyte server.\" , example = \"127.0.0.1\" , ) server_port : int = Field ( default = 8000 , description = \"Port number of Airbyte server.\" , ) api_version : str = Field ( default = \"v1\" , description = \"Airbyte API version to use.\" , title = \"API Version\" , ) use_ssl : bool = Field ( default = False , description = \"Whether to use SSL when connecting to Airbyte server.\" , title = \"Use SSL\" , ) @property def base_url ( self ) -> str : \"\"\"Property containing the base URL for the Airbyte API.\"\"\" protocol = \"https\" if self . use_ssl else \"http\" return ( f \" { protocol } :// { self . server_host } : { self . server_port } /api/ { self . api_version } \" ) def get_client ( self , logger : Logger , timeout : int = 10 ) -> AirbyteClient : \"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API. Args: logger: Logger instance used to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. Returns: An `AirbyteClient` instance. \"\"\" return AirbyteClient ( logger = logger , airbyte_base_url = self . base_url , auth = ( self . username , self . password . get_secret_value ()), timeout = timeout , ) Attributes base_url : str property Property containing the base URL for the Airbyte API. Functions get_client Returns an AirbyteClient instance for interacting with the Airbyte API. Parameters: Name Type Description Default logger Logger Logger instance used to log messages related to API calls. required timeout int The number of seconds to wait before an API call times out. 10 Returns: Type Description AirbyteClient An AirbyteClient instance. Source code in prefect_airbyte/server.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def get_client ( self , logger : Logger , timeout : int = 10 ) -> AirbyteClient : \"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API. Args: logger: Logger instance used to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. Returns: An `AirbyteClient` instance. \"\"\" return AirbyteClient ( logger = logger , airbyte_base_url = self . base_url , auth = ( self . username , self . password . get_secret_value ()), timeout = timeout , )","title":"Server"},{"location":"server/#prefect_airbyte.server","text":"A module for defining OSS Airbyte interactions with Prefect.","title":"server"},{"location":"server/#prefect_airbyte.server-classes","text":"","title":"Classes"},{"location":"server/#prefect_airbyte.server.AirbyteServer","text":"Bases: Block A block representing an Airbyte server for generating AirbyteClient instances. Attributes: Name Type Description username str Username for Airbyte API. password SecretStr Password for Airbyte API. server_host str Hostname for Airbyte API. server_port int Port for Airbyte API. api_version str Version of Airbyte API to use. use_ssl bool Whether to use a secure url for calls to the Airbyte API. Example from prefect_airbyte.server import AirbyteServer server = AirbyteServer . load ( \"BLOCK_NAME\" ) Source code in prefect_airbyte/server.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class AirbyteServer ( Block ): \"\"\"A block representing an Airbyte server for generating `AirbyteClient` instances. Attributes: username: Username for Airbyte API. password: Password for Airbyte API. server_host: Hostname for Airbyte API. server_port: Port for Airbyte API. api_version: Version of Airbyte API to use. use_ssl: Whether to use a secure url for calls to the Airbyte API. Example: ```python from prefect_airbyte.server import AirbyteServer server = AirbyteServer.load(\"BLOCK_NAME\") ``` \"\"\" _block_type_name = \"Airbyte Server\" _block_type_slug = \"airbyte-server\" _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/6gm7wsC7ANnKYQsm7oiSYz/aac1ad5e054d35d9e24af8d6ed3aed5f/59758427?h=250\" # noqa username : str = Field ( default = \"airbyte\" , description = \"Username to authenticate with Airbyte API.\" , ) password : SecretStr = Field ( default = SecretStr ( \"password\" ), description = \"Password to authenticate with Airbyte API.\" , ) server_host : str = Field ( default = \"localhost\" , description = \"Host address of Airbyte server.\" , example = \"127.0.0.1\" , ) server_port : int = Field ( default = 8000 , description = \"Port number of Airbyte server.\" , ) api_version : str = Field ( default = \"v1\" , description = \"Airbyte API version to use.\" , title = \"API Version\" , ) use_ssl : bool = Field ( default = False , description = \"Whether to use SSL when connecting to Airbyte server.\" , title = \"Use SSL\" , ) @property def base_url ( self ) -> str : \"\"\"Property containing the base URL for the Airbyte API.\"\"\" protocol = \"https\" if self . use_ssl else \"http\" return ( f \" { protocol } :// { self . server_host } : { self . server_port } /api/ { self . api_version } \" ) def get_client ( self , logger : Logger , timeout : int = 10 ) -> AirbyteClient : \"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API. Args: logger: Logger instance used to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. Returns: An `AirbyteClient` instance. \"\"\" return AirbyteClient ( logger = logger , airbyte_base_url = self . base_url , auth = ( self . username , self . password . get_secret_value ()), timeout = timeout , )","title":"AirbyteServer"},{"location":"server/#prefect_airbyte.server.AirbyteServer-attributes","text":"","title":"Attributes"},{"location":"server/#prefect_airbyte.server.AirbyteServer.base_url","text":"Property containing the base URL for the Airbyte API.","title":"base_url"},{"location":"server/#prefect_airbyte.server.AirbyteServer-functions","text":"","title":"Functions"},{"location":"server/#prefect_airbyte.server.AirbyteServer.get_client","text":"Returns an AirbyteClient instance for interacting with the Airbyte API. Parameters: Name Type Description Default logger Logger Logger instance used to log messages related to API calls. required timeout int The number of seconds to wait before an API call times out. 10 Returns: Type Description AirbyteClient An AirbyteClient instance. Source code in prefect_airbyte/server.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def get_client ( self , logger : Logger , timeout : int = 10 ) -> AirbyteClient : \"\"\"Returns an `AirbyteClient` instance for interacting with the Airbyte API. Args: logger: Logger instance used to log messages related to API calls. timeout: The number of seconds to wait before an API call times out. Returns: An `AirbyteClient` instance. \"\"\" return AirbyteClient ( logger = logger , airbyte_base_url = self . base_url , auth = ( self . username , self . password . get_secret_value ()), timeout = timeout , )","title":"get_client()"}]}